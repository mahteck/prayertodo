# Phase III Implementation Tasks - AI-Powered Prayer & Masjid Chatbot

**Project**: SalaatFlow
**Phase**: III
**Date**: 2025-12-29
**Execution Mode**: Sequential tasks for Claude Code

---

## Task Execution Instructions

1. **Sequential Execution**: Tasks MUST be executed in order (A1 → A2 → ... → H10)
2. **Validation Required**: Each task includes success criteria - validate before proceeding
3. **No Manual Coding**: All code generated by Claude Code
4. **Recovery Protocol**: If task fails validation, refine and regenerate (no manual edits)

---

## Section A: Environment & Configuration Setup

### Task A1: Create Chatbot Directory Structure

**Files to Create**:
- `phase2_new/backend/chatbot/__init__.py`
- `phase2_new/backend/chatbot/agent/__init__.py`
- `phase2_new/backend/chatbot/mcp_tools/__init__.py`
- `phase2_new/backend/chatbot/utils/__init__.py`
- `phase2_new/backend/chatbot/config/__init__.py`

**Description**:
Create the complete directory structure for the chatbot module within the existing Phase II backend. All `__init__.py` files should be empty or contain minimal imports to make directories valid Python packages.

**Success Criteria**:
- All directories and `__init__.py` files exist
- Can run: `python -c "import chatbot; import chatbot.agent; import chatbot.mcp_tools; import chatbot.utils; import chatbot.config"` without errors

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "import chatbot; print('✅ Chatbot module structure created')"
```

---

### Task A2: Update Backend Dependencies

**Files to Modify**:
- `phase2_new/backend/requirements.txt`

**Description**:
Add Phase III dependencies to `requirements.txt`:
```
openai>=1.12.0
python-dateutil>=2.8.2
```

After adding, install dependencies.

**Success Criteria**:
- Dependencies added to `requirements.txt`
- `pip install -r requirements.txt` succeeds
- Can import: `import openai`, `import dateutil`

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
pip install -r requirements.txt
python -c "import openai; import dateutil; print('✅ Dependencies installed')"
```

---

### Task A3: Create Chatbot Settings Module

**Files to Create**:
- `phase2_new/backend/chatbot/config/settings.py`

**Description**:
Create a settings module that loads Phase III environment variables:
- `OPENAI_API_KEY` (required)
- `BACKEND_BASE_URL` (default: "http://localhost:8000")
- `CHATBOT_MODEL` (default: "gpt-4")
- `CHATBOT_TEMPERATURE` (default: 0.7, type: float)
- `CHATBOT_MAX_TOKENS` (default: 1000, type: int)
- `CHATBOT_TIMEOUT` (default: 30, type: int)
- `DEFAULT_AREA` (optional, type: str)
- `DEFAULT_MASJID_ID` (optional, type: int)

Use `os.getenv()` to load from environment. Raise `ValueError` if `OPENAI_API_KEY` is not set.

**Success Criteria**:
- Settings module loads without errors
- All variables have correct defaults
- Raises `ValueError` if `OPENAI_API_KEY` is missing

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
export OPENAI_API_KEY=sk-test-key
python -c "from chatbot.config.settings import OPENAI_API_KEY, BACKEND_BASE_URL; print('✅ Settings loaded:', BACKEND_BASE_URL)"
```

---

### Task A4: Update Backend .env and .env.example

**Files to Modify**:
- `phase2_new/backend/.env`
- `phase2_new/backend/.env.example`

**Description**:
Add Phase III environment variables to both `.env` and `.env.example`:

For `.env.example` (with placeholder):
```bash
# Phase III - Chatbot Configuration
OPENAI_API_KEY=sk-your-openai-api-key-here
BACKEND_BASE_URL=http://localhost:8000
CHATBOT_MODEL=gpt-4
CHATBOT_TEMPERATURE=0.7
CHATBOT_MAX_TOKENS=1000
CHATBOT_TIMEOUT=30
DEFAULT_AREA=North Nazimabad
DEFAULT_MASJID_ID=1
```

For `.env` (same content - user will replace placeholder with real key).

**Success Criteria**:
- Both files contain Phase III variables
- `.env.example` has placeholder API key
- Variables match settings.py expectations

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
cat .env.example | grep OPENAI_API_KEY
cat .env | grep OPENAI_API_KEY
echo "✅ Environment files updated"
```

---

### Task A5: Create Error Messages Configuration

**Files to Create**:
- `phase2_new/backend/chatbot/config/error_messages.json`

**Description**:
Create a JSON file with error message templates in English and Urdu for:
- `masjid_not_found`
- `area_unknown`
- `task_not_found`
- `invalid_datetime`
- `invalid_recurrence`
- `backend_error`
- `ambiguous_task`

Format:
```json
{
  "error_code": {
    "en": "English message with {placeholder}",
    "ur": "Urdu message with {placeholder}"
  }
}
```

Use exact messages from Phase III specification Section 3.6.3.

**Success Criteria**:
- JSON file is valid
- All 7 error codes present
- Each code has "en" and "ur" keys
- Messages include placeholders like {name}, {area}, {count}, {input}

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
python -c "import json; data = json.load(open('chatbot/config/error_messages.json')); print('✅ Error messages:', len(data), 'codes')"
```

---

### Task A6: Create Phase III Configuration Documentation

**Files to Create**:
- `phase2_new/docs/phase3_config.md`

**Description**:
Create a Markdown document explaining:
1. All Phase III environment variables (name, purpose, type, default, required/optional)
2. How to set up `.env` file for Phase III
3. How to obtain OpenAI API key
4. Configuration troubleshooting tips

Use clear headings and examples.

**Success Criteria**:
- Document exists at correct path
- All 8 environment variables documented
- Setup instructions clear and complete
- Includes troubleshooting section

**Validation**:
```bash
cat /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/docs/phase3_config.md | grep OPENAI_API_KEY
echo "✅ Configuration documentation created"
```

---

## Section B: MCP Tool Layer (Backend Integration)

### Task B1: Create Base MCP Tool Class

**Files to Create**:
- `phase2_new/backend/chatbot/mcp_tools/base.py`

**Description**:
Implement a `MCPTool` class that:
1. Stores tool metadata (name, description, input_schema)
2. Stores backend configuration (method, path)
3. Has `execute(user_id: int, **kwargs) -> dict` method that:
   - Builds URL from `BACKEND_BASE_URL` + path
   - Replaces path parameters (e.g., `{task_id}`) from kwargs
   - Makes HTTP request using `requests` library
   - Returns parsed JSON response or error dict
4. Has `to_openai_tool_schema() -> dict` method that converts to OpenAI function calling format
5. Handles HTTP errors:
   - 404 → `{"error": "NOT_FOUND", "message": "Resource not found"}`
   - 500+ → `{"error": "BACKEND_ERROR", "message": "Backend service error"}`
   - Timeout/connection → `{"error": "CONNECTION_ERROR", "message": str(e)}`

**Success Criteria**:
- `MCPTool` class implements all required methods
- Can instantiate a test tool
- `to_openai_tool_schema()` returns valid OpenAI function schema
- Error handling covers all scenarios

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.mcp_tools.base import MCPTool
tool = MCPTool(
    name='test_tool',
    description='Test',
    input_schema={'type': 'object', 'properties': {}},
    backend_config={'method': 'GET', 'path': '/api/v1/tasks'}
)
schema = tool.to_openai_tool_schema()
print('✅ Base MCP Tool:', schema['function']['name'])
"
```

---

### Task B2: Implement Spiritual Task MCP Tools

**Files to Create**:
- `phase2_new/backend/chatbot/mcp_tools/spiritual_tasks.py`

**Description**:
Create 6 MCP tools using the `MCPTool` base class:

1. **`create_spiritual_task`**
   - Description: "Creates a new spiritual task (prayer, deed, etc.) for the user"
   - Input schema: user_id (int), title (str), description (str, optional), category (enum: Farz/Sunnah/Nafl/Deed/Other), priority (enum: High/Medium/Low), masjid_id (int, optional), due_datetime (str, optional), recurrence (str, optional), recurrence_pattern (str, optional), minutes_before_prayer (int, optional), linked_prayer (str, optional)
   - Backend: POST /api/v1/tasks

2. **`list_spiritual_tasks`**
   - Description: "Lists spiritual tasks for the user with optional filters"
   - Input schema: user_id (int), category (str, optional), completed (bool, optional), priority (str, optional), due_date (str, optional), masjid_id (int, optional)
   - Backend: GET /api/v1/tasks (with query params)

3. **`update_spiritual_task`**
   - Description: "Updates an existing spiritual task"
   - Input schema: task_id (int), user_id (int), title (str, optional), description (str, optional), category (str, optional), priority (str, optional), masjid_id (int, optional), due_datetime (str, optional), recurrence (str, optional), completed (bool, optional), minutes_before_prayer (int, optional), linked_prayer (str, optional)
   - Backend: PUT /api/v1/tasks/{task_id}

4. **`complete_spiritual_task`**
   - Description: "Marks a spiritual task as completed"
   - Input schema: task_id (int), user_id (int)
   - Backend: PATCH /api/v1/tasks/{task_id}/complete

5. **`uncomplete_spiritual_task`**
   - Description: "Marks a spiritual task as not completed"
   - Input schema: task_id (int), user_id (int)
   - Backend: PATCH /api/v1/tasks/{task_id}/incomplete

6. **`delete_spiritual_task`**
   - Description: "Deletes a spiritual task"
   - Input schema: task_id (int), user_id (int)
   - Backend: DELETE /api/v1/tasks/{task_id}

Create list `TASK_TOOLS = [create_task_tool, list_tasks_tool, ...]` and function `get_task_tools()` that returns list of OpenAI schemas.

**Success Criteria**:
- All 6 tools defined
- Each tool has correct input_schema matching OpenAI function calling format
- `get_task_tools()` returns list of 6 tool schemas
- Can import and instantiate tools

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.mcp_tools.spiritual_tasks import get_task_tools, TASK_TOOLS
tools = get_task_tools()
print('✅ Spiritual task tools:', len(tools), 'tools')
print('Tool names:', [t['function']['name'] for t in tools])
"
```

---

### Task B3: Implement Masjid MCP Tools

**Files to Create**:
- `phase2_new/backend/chatbot/mcp_tools/masjids.py`

**Description**:
Create 4 MCP tools using the `MCPTool` base class:

1. **`list_masjids_by_area`**
   - Description: "Lists all masjids in a specific area"
   - Input schema: area (str, required)
   - Backend: GET /api/v1/masjids?area_name={area}

2. **`search_masjid_by_name`**
   - Description: "Searches for masjids by name, optionally filtered by area"
   - Input schema: name (str, required), area (str, optional)
   - Backend: GET /api/v1/masjids with filters (may need to list all and filter by name - check Phase II API)

3. **`get_masjid_details`**
   - Description: "Gets full details including all prayer times for a specific masjid"
   - Input schema: masjid_id (int, required)
   - Backend: GET /api/v1/masjids/{masjid_id}

4. **`get_prayer_time`**
   - Description: "Gets a specific prayer time for a masjid"
   - Input schema: masjid_id (int, required), prayer_name (str, enum: Fajr/Dhuhr/Asr/Maghrib/Isha/Jummah)
   - Backend: GET /api/v1/masjids/{masjid_id}, then extract specific prayer time field

Create list `MASJID_TOOLS` and function `get_masjid_tools()`.

**Success Criteria**:
- All 4 tools defined
- Each tool has correct input_schema
- `get_masjid_tools()` returns list of 4 tool schemas
- Tools correctly map to Phase II masjid endpoints

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.mcp_tools.masjids import get_masjid_tools, MASJID_TOOLS
tools = get_masjid_tools()
print('✅ Masjid tools:', len(tools), 'tools')
print('Tool names:', [t['function']['name'] for t in tools])
"
```

---

### Task B4: Implement Hadith MCP Tool

**Files to Create**:
- `phase2_new/backend/chatbot/mcp_tools/hadith.py`

**Description**:
Create 1 MCP tool using the `MCPTool` base class:

1. **`get_daily_hadith`**
   - Description: "Retrieves today's hadith in both English and Urdu"
   - Input schema: {} (no parameters - returns today's hadith with both languages)
   - Backend: GET /api/v1/hadith/today (or similar - check Phase II hadith endpoint)

The tool should return the full hadith object with both `hadith_text_en` and `hadith_text_ur` fields. The agent will select the appropriate language.

Create list `HADITH_TOOLS` and function `get_hadith_tools()`.

**Success Criteria**:
- Tool defined with correct schema
- `get_hadith_tools()` returns list with 1 tool schema
- Tool maps to Phase II hadith endpoint

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.mcp_tools.hadith import get_hadith_tools, HADITH_TOOLS
tools = get_hadith_tools()
print('✅ Hadith tools:', len(tools), 'tool')
print('Tool name:', tools[0]['function']['name'])
"
```

---

### Task B5: Create MCP Tools Registry

**Files to Create**:
- `phase2_new/backend/chatbot/mcp_tools/__init__.py` (update from empty)

**Description**:
Update the `__init__.py` to create a central registry:

1. Import all tool lists:
   - `from .spiritual_tasks import TASK_TOOLS, get_task_tools`
   - `from .masjids import MASJID_TOOLS, get_masjid_tools`
   - `from .hadith import HADITH_TOOLS, get_hadith_tools`

2. Implement `get_all_tools() -> list`:
   - Returns combined list of all tool schemas (11 total)

3. Implement `execute_tool(tool_name: str, user_id: int, **kwargs) -> dict`:
   - Creates map of tool_name → tool object
   - Looks up tool by name
   - Calls tool.execute(user_id, **kwargs)
   - Returns result or `{"error": "TOOL_NOT_FOUND"}`

4. Add logging for tool executions

**Success Criteria**:
- `get_all_tools()` returns 11 tool schemas
- `execute_tool()` can call any tool by name
- Logging configured for tool calls

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.mcp_tools import get_all_tools, execute_tool
tools = get_all_tools()
print('✅ Total tools registered:', len(tools))
print('Tool names:', [t['function']['name'] for t in tools])
"
```

---

## Section C: Utility Modules

### Task C1: Implement Language Detection Utility

**Files to Create**:
- `phase2_new/backend/chatbot/utils/language.py`

**Description**:
Implement `detect_language(user_message: str) -> str` function that:
1. Defines list of Urdu keywords: `["aaj", "kal", "ka", "kya", "hai", "mujhe", "sunao", "do", "bana", "se", "pehle", "baad", "mein", "main", "namaz", "sadaqah", "karna", "chahiye"]`
2. Converts message to lowercase
3. Counts how many Urdu keywords are in the message
4. Returns `"ur"` if count >= 2, else `"en"`

Add docstring with examples.

**Success Criteria**:
- Function exists and is importable
- Returns correct language for test cases:
  - `"Show me today's hadith"` → `"en"`
  - `"Aaj ka hadith sunao"` → `"ur"`
  - `"Fajr ka time kya hai?"` → `"ur"`
  - `"Add a task"` → `"en"`

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.utils.language import detect_language
assert detect_language('Show me today hadith') == 'en'
assert detect_language('Aaj ka hadith sunao') == 'ur'
assert detect_language('Fajr ka time kya hai?') == 'ur'
print('✅ Language detection working')
"
```

---

### Task C2: Implement DateTime Parser Utility

**Files to Create**:
- `phase2_new/backend/chatbot/utils/datetime_parser.py`

**Description**:
Implement datetime parsing utilities:

1. **`parse_relative_date(text: str) -> datetime`**
   - Parses: "tomorrow", "today", "tonight"
   - Returns datetime object for that date
   - Uses `datetime.now()` as reference

2. **`parse_prayer_relative_time(prayer: str, minutes_offset: int, direction: str, masjid_times: dict, target_date: datetime = None) -> datetime`**
   - Args:
     - prayer: "Fajr", "Dhuhr", etc.
     - minutes_offset: integer (e.g., 20)
     - direction: "before" or "after"
     - masjid_times: dict with keys like `"fajr_time": "05:30"`
     - target_date: optional, defaults to today
   - Returns: datetime calculated from prayer time ± offset

3. **`extract_time_from_text(text: str) -> tuple[int, int] | None`**
   - Parses: "5:30 AM", "1:00 PM", "17:30"
   - Returns: (hour, minute) tuple or None

Import `dateutil.parser` for advanced parsing if needed.

**Success Criteria**:
- All 3 functions implemented
- `parse_relative_date("tomorrow")` returns tomorrow's date
- `parse_prayer_relative_time("Fajr", 20, "before", {"fajr_time": "05:30"})` returns time at 5:10 AM
- `extract_time_from_text("5:30 AM")` returns (5, 30)

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from datetime import datetime, timedelta
from chatbot.utils.datetime_parser import parse_relative_date, parse_prayer_relative_time, extract_time_from_text

tomorrow = datetime.now() + timedelta(days=1)
result = parse_relative_date('tomorrow')
assert result.day == tomorrow.day

result = parse_prayer_relative_time('Fajr', 20, 'before', {'fajr_time': '05:30'})
assert result.hour == 5 and result.minute == 10

time = extract_time_from_text('5:30 AM')
assert time == (5, 30)

print('✅ DateTime parsing working')
"
```

---

### Task C3: Implement Error Handler Utility

**Files to Create**:
- `phase2_new/backend/chatbot/utils/error_handler.py`

**Description**:
Implement error message formatting:

1. **`load_error_messages() -> dict`**
   - Loads `chatbot/config/error_messages.json`
   - Returns dict of error templates

2. **`format_error(error_code: str, language: str, **kwargs) -> str`**
   - Args:
     - error_code: e.g., "masjid_not_found"
     - language: "en" or "ur"
     - **kwargs: placeholder values (name, area, count, input, etc.)
   - Loads error template for code + language
   - Replaces placeholders using kwargs (e.g., `{name}` → kwargs['name'])
   - Returns formatted message
   - Defaults to "backend_error" if code not found

3. Initialize `ERROR_MESSAGES = load_error_messages()` at module level

**Success Criteria**:
- Both functions implemented
- `format_error("masjid_not_found", "en", name="Test")` returns message with "Test" included
- `format_error("invalid_code", "en")` returns backend_error message
- Placeholders correctly replaced

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.utils.error_handler import format_error

msg_en = format_error('masjid_not_found', 'en', name='Test Masjid')
msg_ur = format_error('masjid_not_found', 'ur', name='Test Masjid')

assert 'Test Masjid' in msg_en
assert 'Test Masjid' in msg_ur
print('✅ Error handler working')
print('EN:', msg_en[:50])
print('UR:', msg_ur[:50])
"
```

---

## Section D: Agent Definition (OpenAI Agents SDK)

### Task D1: Create Agent System Prompt

**Files to Create**:
- `phase2_new/backend/chatbot/agent/prompts.py`

**Description**:
Create a module with the complete system prompt as a string constant `SYSTEM_PROMPT`.

The prompt must include (from Phase III Specification Section 4.3.1):
1. Introduction: "You are SalaatFlow Assistant..."
2. Context about the system
3. Core Principles (5 points: Respect, User-Centric, Accuracy, Safety, Clarity)
4. Capabilities list
5. Tools Available list (11 tools)
6. Language Handling rules (detect, respond, switch)
7. Error Handling guidelines
8. Confirmation Required rules (destructive operations)
9. Recurrence & Prayer-Relative Time instructions
10. Constitution reminder (no manual coding)

Use multi-line string (triple quotes). Make it comprehensive (500-800 lines).

Also create constants for additional instruction sections:
- `RECURRENCE_INSTRUCTIONS`
- `LANGUAGE_GUIDELINES`
- `SAFETY_CONFIRMATION_RULES`

These can be appended to main prompt.

**Success Criteria**:
- `SYSTEM_PROMPT` constant exists and is a long string
- Includes all required sections from spec
- Mentions all 11 tools
- Language rules clear
- Confirmation rules explicit
- Can import and print first 100 chars

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.agent.prompts import SYSTEM_PROMPT
print('✅ System prompt loaded, length:', len(SYSTEM_PROMPT))
print('First 200 chars:', SYSTEM_PROMPT[:200])
assert 'SalaatFlow' in SYSTEM_PROMPT
assert 'create_spiritual_task' in SYSTEM_PROMPT
"
```

---

### Task D2: Create Agent Configuration

**Files to Create**:
- `phase2_new/backend/chatbot/agent/config.py`

**Description**:
Create configuration dict for the agent:

```python
from chatbot.config.settings import CHATBOT_MODEL, CHATBOT_TEMPERATURE, CHATBOT_MAX_TOKENS, CHATBOT_TIMEOUT

AGENT_CONFIG = {
    "model": CHATBOT_MODEL,
    "temperature": CHATBOT_TEMPERATURE,
    "max_tokens": CHATBOT_MAX_TOKENS,
    "max_tool_calls": 10,
    "max_recursion_depth": 5,
    "timeout": CHATBOT_TIMEOUT,
}
```

**Success Criteria**:
- `AGENT_CONFIG` dict exists
- All 6 keys present
- Values loaded from settings module
- Can import without errors

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
export OPENAI_API_KEY=sk-test
python -c "
from chatbot.agent.config import AGENT_CONFIG
print('✅ Agent config:', AGENT_CONFIG)
assert 'model' in AGENT_CONFIG
assert AGENT_CONFIG['max_tool_calls'] == 10
"
```

---

### Task D3: Implement Agent Core Logic

**Files to Create**:
- `phase2_new/backend/chatbot/agent/agent.py`

**Description**:
Implement OpenAI Agents SDK integration:

1. **`initialize_agent() -> Assistant`**
   - Creates OpenAI client with API key from settings
   - Calls `client.beta.assistants.create()` with:
     - name="SalaatFlow Assistant"
     - instructions=SYSTEM_PROMPT
     - tools=get_all_tools() (from mcp_tools)
     - model=AGENT_CONFIG["model"]
   - Returns Assistant object

2. **`run_agent(agent: Assistant, user_id: int, user_message: str, conversation_history: list) -> str`**
   - Creates thread with conversation_history
   - Adds user_message to thread
   - Runs the agent
   - Polls for completion (handle "queued", "in_progress", "requires_action")
   - When "requires_action", calls `handle_tool_calls()`
   - Returns final assistant message content

3. **`handle_tool_calls(tool_calls: list, user_id: int) -> list`**
   - Iterates through tool_calls
   - For each call:
     - Extract tool name and arguments (JSON parse)
     - Call `execute_tool(tool_name, user_id, **args)`
     - Format result as tool output
   - Returns list of tool outputs

Add logging for:
- Agent initialization
- User messages
- Tool calls (name + args)
- Agent responses

Import:
- `from openai import OpenAI`
- `from chatbot.agent.config import AGENT_CONFIG`
- `from chatbot.agent.prompts import SYSTEM_PROMPT`
- `from chatbot.mcp_tools import get_all_tools, execute_tool`
- `from chatbot.config.settings import OPENAI_API_KEY`
- `import json, time, logging`

**Success Criteria**:
- All 3 functions implemented
- `initialize_agent()` creates Assistant (requires valid OPENAI_API_KEY)
- Functions handle errors gracefully
- Logging statements in place

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
export OPENAI_API_KEY=sk-real-key-here  # User must provide real key
python -c "
from chatbot.agent.agent import initialize_agent
agent = initialize_agent()
print('✅ Agent initialized:', agent.id)
"
```

**Note**: This requires a valid OpenAI API key. If testing without key, ensure functions are defined correctly and can be imported.

---

## Section E: Chatbot HTTP Endpoint

### Task E1: Update Backend Models for Phase III Fields

**Files to Modify**:
- `phase2_new/backend/models.py`

**Description**:
Add Phase III fields to the `SpiritualTask` model:

1. Add enum for LinkedPrayer:
```python
class LinkedPrayer(str, Enum):
    """Prayer names for linking tasks to prayer times"""
    FAJR = "Fajr"
    DHUHR = "Dhuhr"
    ASR = "Asr"
    MAGHRIB = "Maghrib"
    ISHA = "Isha"
    JUMMAH = "Jummah"
```

2. Add fields to `SpiritualTask`:
```python
# Phase III additions
user_id: Optional[int] = Field(default=1, index=True)
minutes_before_prayer: Optional[int] = Field(default=None)
linked_prayer: Optional[LinkedPrayer] = Field(default=None)
recurrence_pattern: Optional[str] = Field(default=None, max_length=50)
```

All new fields must be Optional to maintain backward compatibility.

**Success Criteria**:
- Enum `LinkedPrayer` added
- 4 new fields added to `SpiritualTask`
- Model can be imported without errors
- Existing Phase II functionality not broken

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from models import SpiritualTask, LinkedPrayer
print('✅ Models updated with Phase III fields')
print('LinkedPrayer values:', [p.value for p in LinkedPrayer])
"
```

---

### Task E2: Create Database Migration for Phase III Fields

**Files to Create**:
- New Alembic migration file (auto-generated)

**Description**:
Create and run Alembic migration for new fields:

1. Generate migration:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
alembic revision --autogenerate -m "Add Phase III chatbot fields to SpiritualTask"
```

2. Review migration file (should add 4 new columns)

3. Run migration:
```bash
alembic upgrade head
```

**Success Criteria**:
- Migration file created in `alembic/versions/`
- Migration adds 4 columns: user_id, minutes_before_prayer, linked_prayer, recurrence_pattern
- Migration runs without errors
- Database schema updated

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
alembic upgrade head
python -c "
from database import engine
from sqlmodel import text
with engine.connect() as conn:
    result = conn.execute(text('PRAGMA table_info(spiritual_tasks)'))
    columns = [row[1] for row in result]
    assert 'user_id' in columns
    assert 'minutes_before_prayer' in columns
    print('✅ Migration applied, new columns:', columns)
"
```

---

### Task E3: Update Tasks Router for user_id Filter

**Files to Modify**:
- `phase2_new/backend/routers/tasks.py`

**Description**:
Update the `list_tasks` endpoint to support filtering by `user_id`:

1. Add parameter:
```python
user_id: Optional[int] = Query(None, description="Filter by user ID")
```

2. Add filter in query builder:
```python
if user_id:
    query = query.where(SpiritualTask.user_id == user_id)
```

This should be added to the `list_tasks` function around line 20-35.

**Success Criteria**:
- `user_id` parameter added to list_tasks
- Filter logic added to query builder
- Endpoint still works without user_id (backward compatible)
- Can filter by user_id: `GET /api/v1/tasks?user_id=1`

**Validation**:
```bash
# Start backend
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python main.py &
sleep 3

# Test endpoint
curl "http://localhost:8000/api/v1/tasks?user_id=1"
echo "✅ Tasks endpoint supports user_id filter"

# Stop backend
pkill -f "python main.py"
```

---

### Task E4: Create Chatbot Router

**Files to Create**:
- `phase2_new/backend/routers/chatbot.py`

**Description**:
Create FastAPI router for chat endpoint:

1. Define Pydantic models:
```python
class ChatMessage(BaseModel):
    role: str  # "user" or "assistant"
    content: str

class ChatRequest(BaseModel):
    user_id: int
    message: str
    conversation_history: Optional[List[ChatMessage]] = []

class ChatResponse(BaseModel):
    response: str
    status: str
    language: str
```

2. Create router and endpoint:
```python
router = APIRouter()

@router.post("/", response_model=ChatResponse)
async def chat(request: ChatRequest):
    """
    Chat endpoint - processes user message and returns agent response
    """
    # Detect language
    # Run agent
    # Return response
    # Handle errors
```

3. Implement endpoint logic:
   - Import agent functions and language detection
   - Initialize agent once (use global or dependency)
   - Detect language from message
   - Convert conversation_history to OpenAI format
   - Call `run_agent()`
   - Log interaction
   - Return ChatResponse
   - Wrap in try/except for errors

4. Add logging for all requests/responses

**Success Criteria**:
- Router created with POST /chat endpoint
- All Pydantic models defined
- Endpoint calls agent and returns response
- Error handling returns 500 with user-friendly message
- Logging captures user messages and agent responses

**Validation**:
```bash
# This will be tested in next task after registering router
```

---

### Task E5: Register Chatbot Router in Main App

**Files to Modify**:
- `phase2_new/backend/main.py`

**Description**:
Register the chatbot router in the main FastAPI application:

1. Import router:
```python
from routers import tasks, masjids, hadith, chatbot
```

2. Include router:
```python
app.include_router(
    chatbot.router,
    prefix=f"{settings.api_v1_prefix}/chat",
    tags=["Chatbot"],
)
```

Add this after the existing router registrations (around line 73-91).

**Success Criteria**:
- Router imported
- Router registered with prefix `/api/v1/chat`
- Backend starts without errors
- Chat endpoint appears in /docs

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
export OPENAI_API_KEY=sk-test-key
python main.py &
sleep 3

# Check docs
curl http://localhost:8000/docs | grep -i chat
echo "✅ Chatbot router registered"

# Test endpoint
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "Hello",
    "conversation_history": []
  }'

pkill -f "python main.py"
```

---

### Task E6: Configure Logging for Chatbot

**Files to Modify**:
- `phase2_new/backend/main.py`

**Description**:
Add logging configuration at application startup:

1. Import logging:
```python
import logging
```

2. Add logging config in lifespan or at module level:
```python
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('chatbot.log')
    ]
)
```

This should be added before the FastAPI app is created.

**Success Criteria**:
- Logging configured
- Logs output to console and file
- chatbot.log file created when backend runs
- Log format includes timestamp, name, level, message

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
export OPENAI_API_KEY=sk-test
python main.py &
sleep 3

# Check log file exists
ls -la chatbot.log
cat chatbot.log | head -10
echo "✅ Logging configured"

pkill -f "python main.py"
```

---

## Section F: Frontend Chat UI

### Task F1: Update Frontend Dependencies

**Files to Modify**:
- `phase2_new/frontend/package.json`

**Description**:
Add chat UI dependencies to package.json:

```json
{
  "dependencies": {
    "react-markdown": "^9.0.1",
    "remark-gfm": "^4.0.0"
  }
}
```

After modifying, run `npm install`.

**Success Criteria**:
- Dependencies added to package.json
- `npm install` succeeds
- Can import react-markdown in components

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
npm install
node -e "require('react-markdown'); console.log('✅ Dependencies installed')"
```

---

### Task F2: Create Chat API Client

**Files to Create**:
- `phase2_new/frontend/lib/chatApi.ts`

**Description**:
Create TypeScript API client for chat endpoint:

1. Define types:
```typescript
interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
}

interface ChatResponse {
  response: string;
  status: string;
  language: string;
}
```

2. Implement function:
```typescript
export async function sendChatMessage(
  userId: number,
  message: string,
  conversationHistory: ChatMessage[]
): Promise<ChatResponse>
```

3. Function logic:
   - Get API base URL from env: `process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000'`
   - Make POST request to `/api/v1/chat`
   - Send JSON body with user_id, message, conversation_history
   - Return parsed response
   - Throw error if request fails

**Success Criteria**:
- Types defined
- Function implemented
- Uses correct API URL
- Handles errors with throw

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
cat lib/chatApi.ts | grep sendChatMessage
echo "✅ Chat API client created"
```

---

### Task F3: Create Chat Components - TypingIndicator

**Files to Create**:
- `phase2_new/frontend/components/chat/TypingIndicator.tsx`

**Description**:
Create a simple typing indicator component:

```typescript
export default function TypingIndicator({ visible }: { visible: boolean }) {
  if (!visible) return null;

  return (
    <div className="px-4 py-2">
      <div className="flex items-center gap-2 text-gray-400">
        <div className="flex gap-1">
          <span className="w-2 h-2 bg-orange-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
          <span className="w-2 h-2 bg-orange-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
          <span className="w-2 h-2 bg-orange-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
        </div>
        <span>SalaatFlow is typing...</span>
      </div>
    </div>
  );
}
```

Use Tailwind classes, match Phase II theme (black/orange/white).

**Success Criteria**:
- Component created as React functional component
- Shows three bouncing dots when visible=true
- Returns null when visible=false
- Uses orange color (#f97316 or orange-500)
- Text says "SalaatFlow is typing..."

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
cat components/chat/TypingIndicator.tsx | grep "animate-bounce"
echo "✅ TypingIndicator component created"
```

---

### Task F4: Create Chat Components - MessageInput

**Files to Create**:
- `phase2_new/frontend/components/chat/MessageInput.tsx`

**Description**:
Create message input component with text box and send button:

```typescript
'use client';

import { useState } from 'react';

interface Props {
  onSend: (message: string) => void;
  disabled: boolean;
}

export default function MessageInput({ onSend, disabled }: Props) {
  const [input, setInput] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (input.trim() && !disabled) {
      onSend(input.trim());
      setInput('');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="p-4 border-t border-gray-700">
      <div className="flex gap-2">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          disabled={disabled}
          placeholder="Type your message..."
          className="flex-1 px-4 py-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:outline-none focus:border-orange-500"
        />
        <button
          type="submit"
          disabled={disabled || !input.trim()}
          className="px-6 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Send
        </button>
      </div>
    </form>
  );
}
```

**Success Criteria**:
- Component accepts onSend callback and disabled prop
- Input field with placeholder
- Send button that calls onSend with trimmed text
- Clears input after send
- Disabled state prevents input and submission
- Uses Phase II theme colors

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
cat components/chat/MessageInput.tsx | grep "onSend"
echo "✅ MessageInput component created"
```

---

### Task F5: Create Chat Components - MessageList

**Files to Create**:
- `phase2_new/frontend/components/chat/MessageList.tsx`

**Description**:
Create component to display list of messages with auto-scroll:

```typescript
'use client';

import { useEffect, useRef } from 'react';
import ReactMarkdown from 'react-markdown';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export default function MessageList({ messages }: { messages: Message[] }) {
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div className="flex-1 overflow-y-auto p-4 space-y-4">
      {messages.map((msg, idx) => (
        <div
          key={idx}
          className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
        >
          <div
            className={`max-w-[70%] p-3 rounded-lg ${
              msg.role === 'user'
                ? 'bg-orange-500 text-white'
                : 'bg-gray-800 text-gray-100'
            }`}
          >
            <ReactMarkdown className="prose prose-invert max-w-none">
              {msg.content}
            </ReactMarkdown>
            <div className="text-xs opacity-70 mt-2">
              {msg.timestamp.toLocaleTimeString()}
            </div>
          </div>
        </div>
      ))}
      <div ref={messagesEndRef} />
    </div>
  );
}
```

**Success Criteria**:
- Displays messages in bubbles
- User messages on right (orange background)
- Assistant messages on left (gray background)
- Auto-scrolls to bottom when new message added
- Renders markdown content
- Shows timestamp
- Uses Phase II theme

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
cat components/chat/MessageList.tsx | grep "ReactMarkdown"
echo "✅ MessageList component created"
```

---

### Task F6: Create Chat Components - ChatInterface

**Files to Create**:
- `phase2_new/frontend/components/chat/ChatInterface.tsx`

**Description**:
Create main chat interface component that ties everything together:

```typescript
'use client';

import { useState } from 'react';
import MessageList from './MessageList';
import MessageInput from './MessageInput';
import TypingIndicator from './TypingIndicator';
import { sendChatMessage } from '@/lib/chatApi';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export default function ChatInterface({ userId = 1 }: { userId?: number }) {
  const [messages, setMessages] = useState<Message[]>([
    {
      role: 'assistant',
      content: 'As-salamu alaykum! How can I assist you with your spiritual journey today?',
      timestamp: new Date(),
    },
  ]);
  const [isLoading, setIsLoading] = useState(false);

  const handleSendMessage = async (message: string) => {
    // Add user message
    const userMessage: Message = {
      role: 'user',
      content: message,
      timestamp: new Date(),
    };
    setMessages((prev) => [...prev, userMessage]);

    // Show typing indicator
    setIsLoading(true);

    try {
      // Send to API
      const response = await sendChatMessage(
        userId,
        message,
        messages.map(({ role, content }) => ({ role, content }))
      );

      // Add assistant response
      const assistantMessage: Message = {
        role: 'assistant',
        content: response.response,
        timestamp: new Date(),
      };
      setMessages((prev) => [...prev, assistantMessage]);
    } catch (error) {
      // Show error message
      const errorMessage: Message = {
        role: 'assistant',
        content: 'I encountered an error. Please try again.',
        timestamp: new Date(),
      };
      setMessages((prev) => [...prev, errorMessage]);
      console.error('Chat error:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-[calc(100vh-200px)] max-w-4xl mx-auto bg-gray-900 rounded-lg">
      <MessageList messages={messages} />
      <TypingIndicator visible={isLoading} />
      <MessageInput onSend={handleSendMessage} disabled={isLoading} />
    </div>
  );
}
```

**Success Criteria**:
- Component manages message state
- Initial greeting message present
- handleSendMessage adds user message, calls API, adds response
- Loading state managed correctly
- Error handling shows user-friendly message
- Uses all three sub-components
- Height calculated to fit viewport

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
cat components/chat/ChatInterface.tsx | grep "handleSendMessage"
echo "✅ ChatInterface component created"
```

---

### Task F7: Create Chat Page Route

**Files to Create**:
- `phase2_new/frontend/app/chat/page.tsx`

**Description**:
Create Next.js page for the chat interface:

```typescript
import ChatInterface from '@/components/chat/ChatInterface';

export const metadata = {
  title: 'Chat - SalaatFlow',
  description: 'Chat with SalaatFlow AI Assistant',
};

export default function ChatPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-white mb-2">
          SalaatFlow Assistant
        </h1>
        <p className="text-gray-400">
          Ask me anything about your spiritual tasks, masjids, or daily hadith
        </p>
      </div>

      <ChatInterface userId={1} />
    </div>
  );
}
```

**Success Criteria**:
- Page created at correct path
- Metadata defined
- ChatInterface component imported and rendered
- Page header with title and description
- Uses Phase II theme styling
- Container and padding applied

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
cat app/chat/page.tsx | grep "ChatInterface"
echo "✅ Chat page created"
```

---

### Task F8: Add Chat Link to Navigation

**Files to Modify**:
- Find existing navigation component (likely in `components/` or `app/layout.tsx`)

**Description**:
Add a navigation link to the chat page.

First, locate the navigation component:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
find . -name "*.tsx" -type f | xargs grep -l "nav\|Nav\|navigation" | grep -v node_modules
```

Then add a link:
```typescript
<Link href="/chat" className="nav-link">
  Chat Assistant
</Link>
```

Or if using a different navigation structure, add appropriately.

**Success Criteria**:
- Navigation link added
- Link points to `/chat`
- Link visible in navigation bar
- Clicking link navigates to chat page
- Styling matches other nav links

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
npm run dev &
sleep 5

# Open browser manually and check navigation
echo "✅ Check navigation at http://localhost:3000"

pkill -f "next dev"
```

---

### Task F9: Update Frontend Environment Variables

**Files to Create/Modify**:
- `phase2_new/frontend/.env.local`
- `phase2_new/frontend/.env.local.example`

**Description**:
Add/update environment variable for backend API URL:

For `.env.local.example`:
```
NEXT_PUBLIC_API_URL=http://localhost:8000
```

For `.env.local` (same content - user can modify if needed).

**Success Criteria**:
- Both files exist
- Variable `NEXT_PUBLIC_API_URL` defined
- Default value points to local backend

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
cat .env.local.example | grep NEXT_PUBLIC_API_URL
cat .env.local | grep NEXT_PUBLIC_API_URL
echo "✅ Frontend environment configured"
```

---

## Section G: Reminder & Recurring Task Logic

### Task G1: Enhance Agent Prompt with Recurrence Instructions

**Files to Modify**:
- `phase2_new/backend/chatbot/agent/prompts.py`

**Description**:
Add detailed recurrence handling instructions to the system prompt.

Create additional prompt section:
```python
RECURRENCE_INSTRUCTIONS = """
## Recurring Tasks & Prayer-Relative Times

When user requests a recurring task:
1. Extract recurrence pattern:
   - "daily" or "every day" → recurrence: "Daily", recurrence_pattern: "every_day"
   - "every Friday" or "weekly" → recurrence: "Weekly", recurrence_pattern: "friday"
   - "monthly" → recurrence: "Monthly", recurrence_pattern: "1st" (or specify)

2. When user says "X minutes before [Prayer]":
   - First, resolve masjid (ask if not in context)
   - Use get_masjid_details tool to get prayer times
   - Calculate due_datetime using prayer time - X minutes
   - Store minutes_before_prayer: X and linked_prayer: "[Prayer]"

3. Example flow for "Daily Fajr reminder 20 minutes before":
   - Ask: "Which masjid's Fajr time should I use?"
   - User: "Masjid Al-Huda"
   - Call: search_masjid_by_name(name="Masjid Al-Huda")
   - Get masjid_id and fajr_time (e.g., "05:30")
   - Calculate: due_datetime = tomorrow 5:10 AM (5:30 - 20 min)
   - Call: create_spiritual_task(
       title="Fajr Reminder",
       category="Farz",
       recurrence="Daily",
       recurrence_pattern="every_day",
       minutes_before_prayer=20,
       linked_prayer="Fajr",
       masjid_id=masjid_id,
       due_datetime="2025-12-30T05:10:00"
     )

4. Always ask for masjid clarification if:
   - User mentions prayer-relative time but no masjid in context
   - Multiple masjids match the name

5. Default offsets:
   - "after [Prayer]" → +15 minutes
   - "before [Prayer]" → specified by user or -15 minutes default
"""
```

Then append to main SYSTEM_PROMPT:
```python
SYSTEM_PROMPT = SYSTEM_PROMPT + "\n\n" + RECURRENCE_INSTRUCTIONS
```

**Success Criteria**:
- `RECURRENCE_INSTRUCTIONS` constant added
- Instructions comprehensive and clear
- Examples provided for agent
- Appended to main SYSTEM_PROMPT
- Increased total prompt length

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.agent.prompts import SYSTEM_PROMPT
assert 'recurrence' in SYSTEM_PROMPT.lower()
assert 'minutes_before_prayer' in SYSTEM_PROMPT
print('✅ Recurrence instructions added, prompt length:', len(SYSTEM_PROMPT))
"
```

---

### Task G2: Test Recurrence Scenario via Chat

**Files to Create**:
- `phase2_new/backend/tests/test_recurrence_scenario.py`

**Description**:
Create a test script that simulates the recurring reminder conversation (Script 10 from spec):

```python
import requests
import json

API_URL = "http://localhost:8000/api/v1/chat"

def test_recurring_reminder():
    """
    Test Script 10: Recurring Reminder (Daily Fajr)
    User: "Kal se daily Fajr se 20 minutes pehle mujhe remind karna"
    Expected: Agent asks for masjid
    User: "Masjid Al-Huda"
    Expected: Task created with recurrence fields
    """
    print("Testing recurring reminder scenario...")

    # First message
    response1 = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Kal se daily Fajr se 20 minutes pehle mujhe remind karna",
        "conversation_history": []
    })
    data1 = response1.json()
    print(f"Agent response 1: {data1['response'][:100]}...")

    # Verify agent asks for masjid
    assert "masjid" in data1['response'].lower() or "Masjid" in data1['response']
    print("✅ Agent asked for masjid clarification")

    # Second message
    response2 = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Masjid Al-Huda",
        "conversation_history": [
            {"role": "user", "content": "Kal se daily Fajr se 20 minutes pehle mujhe remind karna"},
            {"role": "assistant", "content": data1['response']}
        ]
    })
    data2 = response2.json()
    print(f"Agent response 2: {data2['response'][:100]}...")

    # Verify task created
    assert "reminder" in data2['response'].lower() or "task" in data2['response'].lower()
    print("✅ Agent confirmed task creation")

    # Verify task in database
    tasks = requests.get("http://localhost:8000/api/v1/tasks?user_id=1").json()
    fajr_reminder = next((t for t in tasks if "Fajr" in t.get('title', '') and t.get('recurrence') == 'Daily'), None)

    assert fajr_reminder is not None, "Fajr reminder task not found"
    assert fajr_reminder['minutes_before_prayer'] == 20
    assert fajr_reminder['linked_prayer'] == 'Fajr'
    assert fajr_reminder['recurrence'] == 'Daily'
    assert fajr_reminder['recurrence_pattern'] == 'every_day'

    print("✅ Recurring reminder test passed!")
    print(f"Task created: {fajr_reminder}")

if __name__ == "__main__":
    test_recurring_reminder()
```

**Success Criteria**:
- Test script created
- Can run script with backend running
- Script sends two messages (request + masjid clarification)
- Verifies agent asks for masjid
- Verifies task created with correct fields
- All assertions pass

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate

# Start backend in background
export OPENAI_API_KEY=sk-real-key
python main.py &
sleep 5

# Run test
python tests/test_recurrence_scenario.py

# Stop backend
pkill -f "python main.py"
```

**Note**: Requires valid OpenAI API key and seeded database with Masjid Al-Huda.

---

## Section H: Multi-Language Handling

### Task H1: Add Language Guidelines to Agent Prompt

**Files to Modify**:
- `phase2_new/backend/chatbot/agent/prompts.py`

**Description**:
Add language handling guidelines to system prompt:

```python
LANGUAGE_GUIDELINES = """
## Language Handling Rules

1. **Detect user language** from their message:
   - English: standard English words, no Urdu keywords
   - Urdu/Roman Urdu: contains keywords like "aaj", "kal", "kya", "hai", "mujhe", "sunao", etc.

2. **Respond in user's language**:
   - If user writes in English → respond in English
   - If user writes in Urdu/Roman Urdu → respond in Urdu/Roman Urdu
   - Maintain language consistency throughout conversation

3. **Language switching**:
   - If user explicitly says "in English" or "English mein" → switch to English
   - If user says "Urdu mein" → switch to Urdu

4. **Hadith language selection**:
   - Use get_daily_hadith tool (returns both en and ur fields)
   - For English conversation: present hadith_text_en
   - For Urdu conversation: present hadith_text_ur
   - Always include source/reference

5. **Example responses**:

   **English:**
   - "I've added a Farz task 'Pray Fajr at Masjid Al-Huda' for tomorrow at 5:30 AM."
   - "You have 3 pending tasks for today."
   - Masjid Al-Huda (North Nazimabad) - Fajr time: 5:30 AM

   **Urdu/Roman Urdu:**
   - "Maine aapka Farz task 'Pray Fajr at Masjid Al-Huda' kal 5:30 AM ke liye add kar diya."
   - "Aaj ke liye aapke paas 3 pending tasks hain."
   - Masjid Al-Huda (North Nazimabad) - Fajr time: 5:30 AM hai

6. **Respectful Islamic terminology:**
   - Always use respectful terms
   - Prophet Muhammad (peace be upon him) or (ﷺ)
   - Include appropriate greetings: "As-salamu alaykum"
   - End hadith responses with respectful phrase
"""
```

Append to SYSTEM_PROMPT:
```python
SYSTEM_PROMPT = SYSTEM_PROMPT + "\n\n" + LANGUAGE_GUIDELINES
```

**Success Criteria**:
- `LANGUAGE_GUIDELINES` constant added
- Comprehensive language rules
- Examples in both languages
- Islamic terminology guidelines
- Appended to SYSTEM_PROMPT

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.agent.prompts import SYSTEM_PROMPT
assert 'Urdu' in SYSTEM_PROMPT
assert 'English' in SYSTEM_PROMPT
assert 'hadith_text_en' in SYSTEM_PROMPT
print('✅ Language guidelines added to prompt')
"
```

---

### Task H2: Test Multi-Language Conversations

**Files to Create**:
- `phase2_new/backend/tests/test_language_detection.py`

**Description**:
Create test script for language detection and response:

```python
import requests

API_URL = "http://localhost:8000/api/v1/chat"

def test_english_conversation():
    """Test English conversation"""
    response = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Show me today's hadith in English",
        "conversation_history": []
    })
    data = response.json()

    assert response.status_code == 200
    assert data['language'] == 'en'
    print("✅ English conversation test passed")
    print(f"Response: {data['response'][:100]}...")

def test_urdu_conversation():
    """Test Urdu conversation"""
    response = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Aaj ka hadith sunao",
        "conversation_history": []
    })
    data = response.json()

    assert response.status_code == 200
    assert data['language'] == 'ur'
    print("✅ Urdu conversation test passed")
    print(f"Response: {data['response'][:100]}...")

def test_language_switching():
    """Test explicit language switch"""
    # Start in Urdu
    response1 = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Aaj ka task dikhaao",
        "conversation_history": []
    })
    data1 = response1.json()
    assert data1['language'] == 'ur'

    # Switch to English
    response2 = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Show in English",
        "conversation_history": [
            {"role": "user", "content": "Aaj ka task dikhaao"},
            {"role": "assistant", "content": data1['response']}
        ]
    })
    data2 = response2.json()
    assert data2['language'] == 'en'

    print("✅ Language switching test passed")

if __name__ == "__main__":
    test_english_conversation()
    test_urdu_conversation()
    test_language_switching()
    print("✅ All language tests passed!")
```

**Success Criteria**:
- Test script created with 3 test functions
- Tests English detection
- Tests Urdu detection
- Tests language switching
- All assertions pass

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
export OPENAI_API_KEY=sk-real-key
python main.py &
sleep 5

python tests/test_language_detection.py

pkill -f "python main.py"
```

---

## Section I: Safety & Confirmation Mechanisms

### Task I1: Add Safety Confirmation Rules to Agent Prompt

**Files to Modify**:
- `phase2_new/backend/chatbot/agent/prompts.py`

**Description**:
Add safety and confirmation rules to system prompt:

```python
SAFETY_CONFIRMATION_RULES = """
## Safety & Confirmation Rules

**ALWAYS request confirmation before:**

1. **Deleting a single task**:
   - English: "Are you sure you want to delete the task '{task_title}'? (Yes/No)"
   - Urdu: "Kya aap '{task_title}' task delete karna chahte hain? (Haan/Nahi)"

2. **Deleting multiple tasks**:
   - English: "You want to delete {count} tasks. Are you sure? (Yes/No)"
   - Urdu: "{count} tasks delete hone wale hain. Kya aap sure hain? (Haan/Nahi)"

3. **Bulk updates** (affecting multiple tasks):
   - English: "This will reschedule {count} tasks to tomorrow. Confirm? (Yes/No)"
   - Urdu: "{count} tasks kal ke liye reschedule honge. Confirm karein? (Haan/Nahi)"

**Confirmation flow:**
1. Ask for confirmation
2. Wait for user response in next message
3. If user says "Yes"/"Haan"/"y"/"yes"/affirmative → execute operation
4. If user says "No"/"Nahi"/"n"/"no"/negative → cancel, say "Operation cancelled"
5. If unclear → ask again: "Please reply with Yes or No"

**IMPORTANT:**
- Before calling delete_spiritual_task tool, you MUST have received explicit confirmation
- Store confirmation state in conversation context
- Do NOT execute destructive operations without confirmation

**DO NOT request confirmation for:**
- Creating tasks
- Updating single task (non-destructive changes like reschedule, rename)
- Marking task complete/incomplete
- Viewing/listing tasks
- Getting hadith or prayer times
- Searching masjids

**Error Handling:**
Use the error formats from error_messages.json:
- If masjid not found → provide helpful message with spelling suggestion
- If task not found → ask if user wants to see current tasks
- If date/time unclear → provide examples of valid formats
- If backend error → apologize and suggest retry
"""
```

Append to SYSTEM_PROMPT:
```python
SYSTEM_PROMPT = SYSTEM_PROMPT + "\n\n" + SAFETY_CONFIRMATION_RULES
```

**Success Criteria**:
- `SAFETY_CONFIRMATION_RULES` constant added
- Clear confirmation requirements
- Confirmation flow detailed
- Examples in both languages
- Error handling guidelines
- Appended to SYSTEM_PROMPT

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "
from chatbot.agent.prompts import SYSTEM_PROMPT
assert 'confirmation' in SYSTEM_PROMPT.lower()
assert 'delete' in SYSTEM_PROMPT.lower()
assert 'Yes/No' in SYSTEM_PROMPT
print('✅ Safety confirmation rules added')
print('Total prompt length:', len(SYSTEM_PROMPT), 'characters')
"
```

---

### Task I2: Test Deletion Confirmation Flow

**Files to Create**:
- `phase2_new/backend/tests/test_confirmation_flow.py`

**Description**:
Create test for deletion confirmation (Script 4 from spec):

```python
import requests

API_URL = "http://localhost:8000/api/v1/chat"
TASKS_URL = "http://localhost:8000/api/v1/tasks"

def test_deletion_confirmation():
    """
    Test Script 4: Complete and Delete Task with Confirmation
    """
    print("Testing deletion confirmation flow...")

    # Create a test task first
    task_response = requests.post(TASKS_URL, json={
        "user_id": 1,
        "title": "Test Charity Task",
        "category": "Deed",
        "priority": "Medium"
    })
    task = task_response.json()
    print(f"✅ Created test task: {task['id']}")

    # Request deletion
    response1 = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Delete my charity task",
        "conversation_history": []
    })
    data1 = response1.json()
    print(f"Agent response 1: {data1['response'][:100]}...")

    # Verify confirmation requested
    assert "sure" in data1['response'].lower() or "confirm" in data1['response'].lower()
    assert "yes" in data1['response'].lower() and "no" in data1['response'].lower()
    print("✅ Agent requested confirmation")

    # Confirm deletion
    response2 = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Yes",
        "conversation_history": [
            {"role": "user", "content": "Delete my charity task"},
            {"role": "assistant", "content": data1['response']}
        ]
    })
    data2 = response2.json()
    print(f"Agent response 2: {data2['response'][:100]}...")

    # Verify deletion confirmed
    assert "deleted" in data2['response'].lower() or "removed" in data2['response'].lower()
    print("✅ Agent confirmed deletion")

    # Verify task deleted from database
    tasks = requests.get(f"{TASKS_URL}?user_id=1").json()
    assert task['id'] not in [t['id'] for t in tasks]
    print("✅ Task removed from database")

    print("✅ Deletion confirmation test passed!")

def test_deletion_cancellation():
    """Test cancelling deletion"""
    print("Testing deletion cancellation...")

    # Create test task
    task_response = requests.post(TASKS_URL, json={
        "user_id": 1,
        "title": "Important Task",
        "category": "Farz",
        "priority": "High"
    })
    task = task_response.json()
    print(f"✅ Created test task: {task['id']}")

    # Request deletion
    response1 = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Delete my important task",
        "conversation_history": []
    })
    data1 = response1.json()

    # Cancel deletion
    response2 = requests.post(API_URL, json={
        "user_id": 1,
        "message": "No",
        "conversation_history": [
            {"role": "user", "content": "Delete my important task"},
            {"role": "assistant", "content": data1['response']}
        ]
    })
    data2 = response2.json()
    print(f"Agent response: {data2['response'][:100]}...")

    # Verify cancellation
    assert "cancel" in data2['response'].lower()
    print("✅ Agent confirmed cancellation")

    # Verify task still exists
    tasks = requests.get(f"{TASKS_URL}?user_id=1").json()
    assert task['id'] in [t['id'] for t in tasks]
    print("✅ Task still in database")

    # Cleanup
    requests.delete(f"{TASKS_URL}/{task['id']}")

    print("✅ Deletion cancellation test passed!")

if __name__ == "__main__":
    test_deletion_confirmation()
    test_deletion_cancellation()
    print("✅ All confirmation tests passed!")
```

**Success Criteria**:
- Test script created with 2 test functions
- Tests deletion confirmation flow
- Tests deletion cancellation flow
- Verifies database state
- All assertions pass

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
export OPENAI_API_KEY=sk-real-key
python main.py &
sleep 5

python tests/test_confirmation_flow.py

pkill -f "python main.py"
```

---

## Section J: Acceptance Testing & Documentation

### Task J1: Create Acceptance Test Documentation

**Files to Create**:
- `phase2_new/docs/phase3_acceptance_tests.md`

**Description**:
Create comprehensive documentation of all 10 acceptance test scripts from the specification.

For each script, document:
1. **Script number and title**
2. **Purpose** (what it validates)
3. **Setup** (any required database state)
4. **Conversation flow** (turn-by-turn user/agent messages)
5. **Expected database changes**
6. **Validation steps**

Format:
```markdown
# Phase III Acceptance Test Scripts

## Script 1: Create Task (English)

**Purpose**: Verify task creation with English input, automatic category classification, and date/time parsing.

**Setup**:
- User ID: 1
- Masjid "Masjid Al-Huda" (ID: 1) exists in database

**Conversation Flow**:

| Turn | Role | Message |
|------|------|---------|
| 1 | User | "Add a task to pray Fajr at Masjid Al-Huda tomorrow at 5:30 AM" |
| 2 | Assistant | "I've added a Farz task 'Pray Fajr at Masjid Al-Huda' for tomorrow (2025-12-30) at 5:30 AM." |

**Expected Database Changes**:
- New SpiritualTask created with:
  - user_id: 1
  - title: "Pray Fajr at Masjid Al-Huda"
  - category: "Farz" (auto-classified)
  - priority: "Medium" (default)
  - masjid_id: 1
  - due_datetime: "2025-12-30T05:30:00"
  - completed: false

**Validation**:
```bash
# Via API
curl "http://localhost:8000/api/v1/tasks?user_id=1" | jq '.[] | select(.title | contains("Fajr"))'

# Via Chat
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{"user_id":1,"message":"Add a task to pray Fajr at Masjid Al-Huda tomorrow at 5:30 AM","conversation_history":[]}'
```

[... continue for all 10 scripts ...]
```

Include all 10 scripts from Specification Section 6.

**Success Criteria**:
- Document created with all 10 scripts
- Each script has all 6 sections
- Validation commands provided
- Clear and detailed

**Validation**:
```bash
cat /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/docs/phase3_acceptance_tests.md | grep "Script" | wc -l
# Should show at least 10
echo "✅ Acceptance tests documented"
```

---

### Task J2: Create Seed Data Script

**Files to Create**:
- `phase2_new/backend/seed_phase3_test_data.py`

**Description**:
Create script to seed database with test data for acceptance tests:

```python
from sqlmodel import Session, select
from database import engine, create_db_and_tables
from models import Masjid, DailyHadith, SpiritualTask
from datetime import date, datetime

def seed_test_data():
    """Seed database with test data for Phase III acceptance tests"""

    create_db_and_tables()

    with Session(engine) as session:
        # Clear existing test data for user_id=1
        existing_tasks = session.exec(
            select(SpiritualTask).where(SpiritualTask.user_id == 1)
        ).all()
        for task in existing_tasks:
            session.delete(task)

        # Seed masjids
        masjids_data = [
            {
                "id": 1,
                "name": "Masjid Al-Huda",
                "area_name": "North Nazimabad",
                "city": "Karachi",
                "fajr_time": "05:30",
                "dhuhr_time": "13:00",
                "asr_time": "16:30",
                "maghrib_time": "18:00",
                "isha_time": "19:30",
                "jummah_time": "13:30"
            },
            {
                "id": 2,
                "name": "Masjid Usman",
                "area_name": "Gulshan",
                "city": "Karachi",
                "fajr_time": "05:25",
                "dhuhr_time": "13:00",
                "asr_time": "16:30",
                "maghrib_time": "18:00",
                "isha_time": "19:30",
                "jummah_time": "13:30"
            },
            {
                "id": 3,
                "name": "Masjid Al-Aqsa",
                "area_name": "North Nazimabad",
                "city": "Karachi",
                "fajr_time": "05:30",
                "dhuhr_time": "13:00",
                "asr_time": "16:30",
                "maghrib_time": "18:00",
                "isha_time": "19:30",
                "jummah_time": "13:30"
            }
        ]

        for masjid_data in masjids_data:
            existing = session.get(Masjid, masjid_data["id"])
            if not existing:
                masjid = Masjid(**masjid_data)
                session.add(masjid)

        # Seed today's hadith
        existing_hadith = session.exec(
            select(DailyHadith).where(DailyHadith.date == date.today())
        ).first()

        if not existing_hadith:
            hadith = DailyHadith(
                date=date.today(),
                hadith_text_en="The best of you are those who learn the Quran and teach it.",
                hadith_text_ur="تم میں سے بہترین وہ ہیں جو قرآن سیکھیں اور سکھائیں۔",
                source="Sahih Bukhari 5027"
            )
            session.add(hadith)

        session.commit()
        print("✅ Test data seeded successfully!")
        print(f"   - Masjids: {len(masjids_data)}")
        print(f"   - Hadith: Today's hadith added")
        print(f"   - Tasks: Cleared for user_id=1")

if __name__ == "__main__":
    seed_test_data()
```

**Success Criteria**:
- Script created
- Seeds 3 masjids
- Seeds today's hadith (both languages)
- Clears existing tasks for user 1
- Can run without errors

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python seed_phase3_test_data.py

# Verify data
curl "http://localhost:8000/api/v1/masjids" | jq length
# Should return 3

curl "http://localhost:8000/api/v1/hadith/today" | jq .hadith_text_en
# Should return hadith text
```

---

### Task J3: Run All 10 Acceptance Scripts Manually

**Files to Create**:
- `phase2_new/docs/phase3_test_results.md`

**Description**:
Create a test results document with manual testing checklist for all 10 scripts.

Format:
```markdown
# Phase III Acceptance Test Results

**Date**: 2025-12-29
**Tester**: [Name]
**Backend**: Running at http://localhost:8000
**Frontend**: Running at http://localhost:3000
**OPENAI_API_KEY**: Configured

---

## Pre-Test Setup

- [ ] Backend started successfully
- [ ] Frontend started successfully
- [ ] Database seeded with test data (ran seed_phase3_test_data.py)
- [ ] OpenAI API key set in .env
- [ ] All Phase II endpoints working

---

## Script 1: Create Task (English)

**Status**: ⏳ Not Started / ✅ Passed / ❌ Failed

**Test Method**: Frontend Chat UI

**Steps**:
1. Open http://localhost:3000/chat
2. Send message: "Add a task to pray Fajr at Masjid Al-Huda tomorrow at 5:30 AM"
3. Observe agent response

**Expected**:
- Agent confirms task creation
- Message mentions "Farz" category
- Message mentions "tomorrow" and "5:30 AM"

**Actual Result**:
[Record actual agent response]

**Database Verification**:
```bash
curl "http://localhost:8000/api/v1/tasks?user_id=1" | jq '.[] | select(.title | contains("Fajr"))'
```

**Notes**:
[Any observations or issues]

---

[... repeat for all 10 scripts ...]

---

## Summary

**Total Scripts**: 10
**Passed**: ___
**Failed**: ___
**Pass Rate**: ___%

**Issues Found**:
1. [Issue description]
2. [Issue description]

**Recommendations**:
- [Recommendations for fixes or improvements]
```

**Success Criteria**:
- Document created with all 10 scripts
- Each script has checklist items
- Space for results and notes
- Summary section at end

**Validation**:
```bash
cat /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/docs/phase3_test_results.md | grep "Script" | wc -l
echo "✅ Test results template created"
```

---

### Task J4: Create Phase III README

**Files to Create**:
- `phase2_new/PHASE3_README.md`

**Description**:
Create comprehensive Phase III documentation covering:

1. **Overview** (what Phase III adds)
2. **Features** (list of capabilities)
3. **Architecture** (diagram and explanation)
4. **Setup Instructions**
   - Prerequisites
   - Backend setup
   - Frontend setup
   - Environment configuration
   - Running the application
5. **API Documentation**
   - POST /api/v1/chat endpoint
   - Request/response format
   - Examples
6. **Usage Guide**
   - How to use chat interface
   - Example conversations
   - Supported commands
7. **Testing**
   - How to run acceptance tests
   - How to seed test data
   - Manual testing guide
8. **Troubleshooting**
   - Common issues and fixes
   - Debugging tips
   - Logs location
9. **Deployment**
   - Production checklist
   - Environment variables
   - Scaling considerations

Use clear headings, code blocks, and examples.

**Success Criteria**:
- Document created with all 9 sections
- Clear and comprehensive
- Code examples provided
- Setup instructions complete
- Troubleshooting guide helpful

**Validation**:
```bash
cat /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/PHASE3_README.md | grep "##" | wc -l
# Should have many section headings
echo "✅ Phase III README created"
```

---

### Task J5: Update Root .gitignore

**Files to Modify**:
- `phase2_new/.gitignore` or root `.gitignore`

**Description**:
Add Phase III-specific entries to .gitignore:

```
# Phase III - Chatbot
backend/chatbot.log
backend/.env
*.log

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
env/

# Node
node_modules/
.next/
.env.local

# IDEs
.vscode/
.idea/
*.swp
*.swo
```

**Success Criteria**:
- .gitignore updated
- All sensitive files excluded
- Log files excluded
- No .env files tracked

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo
cat .gitignore | grep chatbot.log
cat .gitignore | grep "\.env"
echo "✅ .gitignore updated"
```

---

## Final Validation Checklist

### Task J6: Complete System Integration Test

**Description**:
Perform end-to-end integration test of the complete Phase III system.

**Test Steps**:

1. **Backend Startup**:
```bash
cd phase2_new/backend
source venv/bin/activate
export OPENAI_API_KEY=sk-real-key
python seed_phase3_test_data.py
python main.py
```

2. **Frontend Startup**:
```bash
cd phase2_new/frontend
npm run dev
```

3. **Test Phase II Endpoints** (ensure no breaking changes):
```bash
curl http://localhost:8000/health
curl http://localhost:8000/api/v1/tasks
curl http://localhost:8000/api/v1/masjids
curl http://localhost:8000/api/v1/hadith/today
```

4. **Test Chat Endpoint**:
```bash
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "Hello",
    "conversation_history": []
  }'
```

5. **Test Frontend Chat UI**:
- Open http://localhost:3000/chat
- Verify page loads
- Send message "Hello"
- Verify response appears
- Test task creation: "Add Fajr task for tomorrow"
- Test masjid query: "What time is Fajr at Masjid Al-Huda?"
- Test hadith: "Show me today's hadith"

6. **Test Multi-Language**:
- Send Urdu message: "Aaj ka hadith sunao"
- Verify Urdu response

7. **Test Recurrence**:
- Send: "Kal se daily Fajr se 20 minutes pehle remind karna"
- Respond to masjid question: "Masjid Al-Huda"
- Verify task created with recurrence fields

8. **Test Confirmation**:
- Create a task
- Send: "Delete my task"
- Verify confirmation requested
- Respond: "Yes"
- Verify task deleted

**Success Criteria**:
- ✅ All Phase II endpoints working
- ✅ Chat endpoint responding
- ✅ Frontend chat UI functional
- ✅ Can create tasks via chat
- ✅ Can query masjids via chat
- ✅ Can get hadith via chat
- ✅ Multi-language working
- ✅ Recurrence working
- ✅ Confirmations working
- ✅ No console errors
- ✅ No backend errors

**Validation**: Manual execution of all above steps

---

## Summary Statistics

**Total Tasks**: 56
**Sections**: 10 (A-J)

**Breakdown by Section**:
- A: Environment & Config (6 tasks)
- B: MCP Tools (5 tasks)
- C: Utilities (3 tasks)
- D: Agent Definition (3 tasks)
- E: Backend Endpoint (6 tasks)
- F: Frontend UI (9 tasks)
- G: Recurrence Logic (2 tasks)
- H: Multi-Language (2 tasks)
- I: Safety & Confirmation (2 tasks)
- J: Testing & Documentation (6 tasks)

**Estimated Completion Time**: 12-16 hours (sequential execution by Claude Code)

---

## Execution Protocol

1. **Sequential Execution**: Tasks MUST be executed in order (A1 → A2 → ... → J6)
2. **Validation Required**: Validate each task before proceeding to next
3. **No Manual Coding**: All code generated by Claude Code via `/sp.implement`
4. **Recovery**: If task fails, refine and regenerate (do not manually edit)
5. **Documentation**: Update test results document as tests are executed

---

## Success Criteria for Phase III

Phase III is complete and successful when:

1. ✅ All 56 tasks completed and validated
2. ✅ All 10 acceptance test scripts pass
3. ✅ Phase II functionality unchanged (no breaking changes)
4. ✅ Chat UI accessible at /chat and functional
5. ✅ Multi-language support working (EN + UR)
6. ✅ Recurrence and prayer-relative times working
7. ✅ Safety confirmations working
8. ✅ All documentation complete
9. ✅ No API keys or secrets in repository
10. ✅ System passes final integration test (Task J6)

---

**End of Task List**

**Ready for execution with `/sp.implement`! 🚀**

*Generated by Claude Code - Spec-Driven Development*
*Date: 2025-12-29*
