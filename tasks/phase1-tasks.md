# Phase I Tasks â€“ SalaatFlow In-Memory Python Console App

**Project**: SalaatFlow â€“ Intelligent Prayer & Masjid Todo Assistant
**Phase**: I â€“ In-Memory Python Console Application
**Task List Version**: 1.0
**Date**: 2025-12-27
**Status**: Ready for Execution

---

## Task Execution Protocol

### ðŸš¨ Critical Rules

1. **NO MANUAL CODING**: All production code generated by Claude Code from specs
2. **SPEC IS TRUTH**: If code doesn't match spec â†’ refine spec/task â†’ regenerate code
3. **VALIDATE EACH TASK**: Must pass success criteria before proceeding to next
4. **SEQUENTIAL EXECUTION**: Complete tasks in order (dependencies exist)

### Task Workflow

For each task:
1. âœ… Read the task description
2. âœ… Read referenced spec sections (`/specs/phase1-cli.md`)
3. âœ… Generate code via Claude Code
4. âœ… Run validation commands/tests
5. âœ… Mark task complete only if all success criteria pass
6. âœ… If failure â†’ refine task/spec â†’ regenerate (no manual patches)

---

## Task List

### Task 1: Create Project Directory Structure

**Short Title**: Setup Phase I Directory

**Files to Create**:
- `phase1/` (directory)
- `phase1/main.py` (empty placeholder with module docstring)
- `phase1/models.py` (empty placeholder)
- `phase1/storage.py` (empty placeholder)
- `phase1/commands.py` (empty placeholder)
- `phase1/validators.py` (empty placeholder)
- `phase1/display.py` (empty placeholder)
- `phase1/README.md` (initial placeholder)

**Spec Reference**:
- Plan Step 1 (lines 24-77)
- Spec Section 6.3 (Code Structure)

**Success Criteria**:
- [ ] Directory `phase1/` exists
- [ ] All 7 files created (`.py` files and `README.md`)
- [ ] Each `.py` file has module-level docstring describing purpose
- [ ] No syntax errors: `python -m py_compile phase1/*.py`

**Validation Command**:
```bash
ls -la phase1/
python -m py_compile phase1/*.py
```

**Notes**: This task just creates the skeleton. Actual implementation starts in subsequent tasks.

---

### Task 2: Implement Task Data Model

**Short Title**: Create Task Model & Constants

**Files to Create/Update**:
- `phase1/models.py`

**Spec Reference**:
- Spec Section 2.1 (Task Entity - lines 54-70)
- Spec Section 2.2 (Category Enumeration - lines 72-77)
- Plan Step 1 (lines 42-45)

**Implementation Requirements**:
- Define Task as `TypedDict` or `dataclass` with 10 fields:
  - `id: int`
  - `title: str`
  - `description: str`
  - `category: str`
  - `masjid_name: str`
  - `area_name: str`
  - `due_datetime: Optional[datetime]`
  - `completed: bool`
  - `created_at: datetime`
  - `updated_at: datetime`
- Define category constants:
  - `CATEGORY_FARZ = "Farz"`
  - `CATEGORY_SUNNAH = "Sunnah"`
  - `CATEGORY_NAFL = "Nafl"`
  - `CATEGORY_DEED = "Deed"`
  - `CATEGORIES = [CATEGORY_FARZ, CATEGORY_SUNNAH, CATEGORY_NAFL, CATEGORY_DEED]`
- Add type hints throughout
- Add module docstring

**Success Criteria**:
- [ ] `models.py` defines Task structure (dict or dataclass)
- [ ] All 10 required fields present with correct types
- [ ] Four category constants defined exactly as "Farz", "Sunnah", "Nafl", "Deed"
- [ ] `CATEGORIES` list contains all 4 categories
- [ ] All code has type hints
- [ ] Module has docstring
- [ ] Import test passes: `python -c "from phase1.models import *; print('âœ“ Models loaded')"`

**Validation Command**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo
python -c "from phase1.models import CATEGORY_FARZ, CATEGORY_SUNNAH, CATEGORY_NAFL, CATEGORY_DEED, CATEGORIES; print('Categories:', CATEGORIES)"
```

---

### Task 3: Implement Input Validators

**Short Title**: Create Validation Functions

**Files to Create/Update**:
- `phase1/validators.py`

**Spec Reference**:
- Spec Section 3.2.2 (Add command validation - lines 166-174)
- Plan Step 1 (lines 47-52)

**Implementation Requirements**:
- Constants:
  - `MAX_TITLE_LENGTH = 200`
  - `MAX_DESCRIPTION_LENGTH = 1000`
  - `MAX_MASJID_NAME_LENGTH = 100`
  - `MAX_AREA_NAME_LENGTH = 100`
  - `DATETIME_FORMAT = "YYYY-MM-DD HH:MM"`
- Functions:
  - `validate_title(title: str) -> tuple[bool, str]`
    - Returns `(True, "")` if 1-200 chars
    - Returns `(False, "error message")` if invalid
  - `validate_category(choice: str) -> tuple[bool, str]`
    - Accepts "1", "2", "3", "4"
    - Returns `(True, category_name)` if valid
    - Returns `(False, "")` if invalid
  - `validate_datetime(datetime_str: str) -> tuple[bool, Optional[datetime]]`
    - Accepts "YYYY-MM-DD HH:MM" format
    - Returns `(True, datetime_obj)` if valid
    - Returns `(False, None)` if invalid
  - `validate_id(id_str: str) -> tuple[bool, Optional[int]]`
    - Returns `(True, id_int)` if numeric
    - Returns `(False, None)` if non-numeric

**Success Criteria**:
- [ ] All 4 constants defined
- [ ] All 4 validation functions implemented with correct signatures
- [ ] `validate_title` enforces 1-200 character limit
- [ ] `validate_category` accepts only "1"-"4" and maps to category names
- [ ] `validate_datetime` parses "YYYY-MM-DD HH:MM" format correctly
- [ ] `validate_id` correctly identifies numeric strings
- [ ] All functions have docstrings
- [ ] Test: `python -c "from phase1.validators import *; print(validate_title('Test'))"` returns `(True, '')`

**Validation Command**:
```bash
python -c "
from phase1.validators import validate_title, validate_category, validate_datetime, validate_id
print('Title valid:', validate_title('Attend Fajr'))
print('Category valid:', validate_category('1'))
print('Datetime valid:', validate_datetime('2025-12-28 05:30'))
print('ID valid:', validate_id('123'))
"
```

---

### Task 4: Implement In-Memory Storage

**Short Title**: Create TaskStorage Class

**Files to Create/Update**:
- `phase1/storage.py`

**Spec Reference**:
- Spec Section 2.3 (In-Memory Storage - lines 79-102)
- Plan Step 1 (lines 54-62)

**Implementation Requirements**:
- `TaskStorage` class with:
  - Attributes:
    - `tasks: List[dict]` (initialized as empty list)
    - `next_id: int` (initialized as 1)
  - Methods:
    - `add_task(task: dict) -> int`
      - Assigns `task["id"] = next_id`
      - Appends to `tasks`
      - Increments `next_id`
      - Returns assigned ID
    - `get_task(task_id: int) -> Optional[dict]`
      - Returns task dict if found
      - Returns `None` if not found
    - `update_task(task_id: int, updates: dict) -> bool`
      - Updates task fields from `updates` dict
      - Returns `True` if found and updated
      - Returns `False` if not found
    - `delete_task(task_id: int) -> bool`
      - Removes task from list
      - Returns `True` if found and deleted
      - Returns `False` if not found
    - `list_tasks(filter: str = "all") -> List[dict]`
      - `"all"` â†’ returns all tasks
      - `"pending"` â†’ returns tasks where `completed == False`
      - `"completed"` â†’ returns tasks where `completed == True`

**Success Criteria**:
- [ ] `TaskStorage` class defined
- [ ] All 5 methods implemented with correct signatures
- [ ] `add_task` auto-assigns IDs starting from 1
- [ ] `get_task` returns correct task or None
- [ ] `update_task` modifies existing task fields
- [ ] `delete_task` removes task from list
- [ ] `list_tasks` filters correctly by completion status
- [ ] All methods have docstrings and type hints
- [ ] Test: Create instance, add task, retrieve task

**Validation Command**:
```bash
python -c "
from phase1.storage import TaskStorage
from datetime import datetime

storage = TaskStorage()
task_id = storage.add_task({
    'title': 'Test Task',
    'description': '',
    'category': 'Farz',
    'masjid_name': '',
    'area_name': '',
    'due_datetime': None,
    'completed': False,
    'created_at': datetime.now(),
    'updated_at': datetime.now()
})
print(f'Added task ID: {task_id}')
print(f'Retrieved task: {storage.get_task(task_id)[\"title\"]}')
print(f'All tasks count: {len(storage.list_tasks())}')
"
```

---

### Task 5: Implement Display Formatting Functions

**Short Title**: Create Display Module

**Files to Create/Update**:
- `phase1/display.py`

**Spec Reference**:
- Spec Section 4.1 (Welcome Banner - lines 360-366)
- Spec Section 3.2.1 (Help Text - lines 123-135)
- Spec Section 3.2.3 (Task Table - lines 188-196)
- Spec Section 3.2.4 (Task Detail - lines 215-226)
- Plan Step 2 (lines 81-134)

**Implementation Requirements**:
- `show_welcome_banner() -> None`
  - Print exact banner from spec section 4.1
- `show_help() -> None`
  - Print exact help text from spec section 3.2.1
- `show_task_table(tasks: List[dict]) -> None`
  - Format tasks in columnar table matching spec section 3.2.3
  - Columns: ID | Status | Category | Title | Masjid | Area | Due Date/Time
  - Use `format_status()` for status column
  - Use `format_datetime()` for datetime column
  - Truncate long titles to fit (max ~30 chars)
  - Show summary: "Total: X tasks (Y completed, Z pending)"
  - Handle empty list: "No tasks found."
- `show_task_detail(task: dict) -> None`
  - Display all fields vertically matching spec section 3.2.4
  - Labels: "Task ID:", "Title:", "Description:", etc.
  - Use `format_datetime()` for timestamps
  - Show "Pending" or "Completed" for status
- `format_datetime(dt: Optional[datetime]) -> str`
  - If `None`, return `"-"`
  - If datetime, return `"YYYY-MM-DD HH:MM"` format
- `format_status(completed: bool) -> str`
  - Return `"[âœ“]"` if `True`
  - Return `"[ ]"` if `False`

**Success Criteria**:
- [ ] `show_welcome_banner()` displays exact banner from spec
- [ ] `show_help()` displays exact help text from spec
- [ ] `show_task_table()` formats table with correct columns and alignment
- [ ] `show_task_detail()` shows all task fields in vertical format
- [ ] `format_datetime()` handles None (returns "-")
- [ ] `format_status()` returns "[âœ“]" or "[ ]"
- [ ] Empty task list shows "No tasks found."
- [ ] Summary line shows correct counts
- [ ] All functions have docstrings

**Validation Command**:
```bash
python -c "
from phase1.display import *
from datetime import datetime

# Test banner and help
show_welcome_banner()
show_help()

# Test table with sample data
sample_tasks = [{
    'id': 1,
    'title': 'Attend Fajr at Masjid Al-Huda',
    'description': 'Wake up early',
    'category': 'Farz',
    'masjid_name': 'Masjid Al-Huda',
    'area_name': 'DHA Phase 5',
    'due_datetime': datetime(2025, 12, 28, 5, 30),
    'completed': False,
    'created_at': datetime.now(),
    'updated_at': datetime.now()
}]
show_task_table(sample_tasks)

# Test detail view
show_task_detail(sample_tasks[0])
"
```

---

### Task 6: Implement Read-Only Command Handlers

**Short Title**: Create help, list, view Commands

**Files to Create/Update**:
- `phase1/commands.py`

**Spec Reference**:
- Spec Section 3.2.1 (help command - lines 117-135)
- Spec Section 3.2.3 (list command - lines 178-206)
- Spec Section 3.2.4 (view command - lines 209-231)
- Plan Step 3 (lines 138-189)

**Implementation Requirements**:
- `handle_help(storage: TaskStorage) -> None`
  - Call `display.show_help()`
- `handle_list(storage: TaskStorage, args: List[str]) -> None`
  - Parse filter from `args[0]` if present (default "all")
  - Validate filter in ["all", "pending", "completed"]
  - If invalid filter, show error: "Error: Invalid filter. Use: all, pending, or completed"
  - Call `storage.list_tasks(filter)`
  - If empty, show "No tasks found." (or "No tasks found matching filter: {filter}")
  - Else call `display.show_task_table(tasks)`
- `handle_view(storage: TaskStorage, args: List[str]) -> None`
  - Check if `args` is empty â†’ show error: "Error: Command 'view' requires argument(s). Usage: view <id>"
  - Validate ID with `validators.validate_id(args[0])`
  - If invalid, show error: "Error: Invalid task ID. Please enter a number."
  - Call `storage.get_task(id)`
  - If not found, show error: "Error: Task with ID {id} not found."
  - Else call `display.show_task_detail(task)`

**Success Criteria**:
- [ ] `handle_help` displays full help text
- [ ] `handle_list` without args shows all tasks
- [ ] `handle_list` with "pending" filters correctly
- [ ] `handle_list` with "completed" filters correctly
- [ ] `handle_list` with invalid filter shows error
- [ ] `handle_view` with valid ID shows task details
- [ ] `handle_view` without ID shows usage error
- [ ] `handle_view` with invalid ID shows error
- [ ] `handle_view` with non-existent ID shows not found error
- [ ] All functions have docstrings and type hints

**Validation Command**:
```bash
python -c "
from phase1.storage import TaskStorage
from phase1.commands import handle_help, handle_list, handle_view
from datetime import datetime

storage = TaskStorage()
storage.add_task({
    'title': 'Test Task',
    'description': 'Test',
    'category': 'Farz',
    'masjid_name': '',
    'area_name': '',
    'due_datetime': None,
    'completed': False,
    'created_at': datetime.now(),
    'updated_at': datetime.now()
})

print('=== Testing help ===')
handle_help(storage)

print('\n=== Testing list ===')
handle_list(storage, [])

print('\n=== Testing view ===')
handle_view(storage, ['1'])

print('\n=== Testing view with invalid ID ===')
handle_view(storage, ['999'])
"
```

---

### Task 7: Implement Add Command with Interactive Prompts

**Short Title**: Create add Command

**Files to Update**:
- `phase1/commands.py`

**Spec Reference**:
- Spec Section 3.2.2 (add command - lines 139-175)
- Plan Step 4 (lines 193-254)

**Implementation Requirements**:
- `prompt_category() -> str`
  - Display numbered menu (1. Farz, 2. Sunnah, 3. Nafl, 4. Deed)
  - Prompt "Enter choice (1-4):"
  - Validate with `validators.validate_category()`
  - Re-prompt on invalid input
  - Return category string
- `prompt_datetime() -> Optional[datetime]`
  - Prompt "Enter due date/time (optional, format: YYYY-MM-DD HH:MM or press Enter to skip):"
  - If empty, return None
  - Validate with `validators.validate_datetime()`
  - Re-prompt on invalid format
  - Return datetime or None
- `prompt_for_task_data() -> dict`
  - Prompt for title (required)
  - Validate with `validators.validate_title()`
  - Re-prompt until valid
  - Prompt for description (optional)
  - Call `prompt_category()`
  - Prompt for masjid_name (optional)
  - Prompt for area_name (optional)
  - Call `prompt_datetime()`
  - Return dict with user-provided values (no id, timestamps, or completed)
- `handle_add(storage: TaskStorage) -> None`
  - Call `prompt_for_task_data()`
  - Add auto-generated fields:
    - `created_at = datetime.now()`
    - `updated_at = datetime.now()`
    - `completed = False`
  - Call `storage.add_task(task)`
  - Display: "Task added successfully! (ID: X)"

**Success Criteria**:
- [ ] Prompts match spec exactly (spec section 3.2.2)
- [ ] Title is required and re-prompts when empty
- [ ] Category menu shows 4 options
- [ ] Invalid category re-prompts
- [ ] Datetime accepts "YYYY-MM-DD HH:MM" format
- [ ] Invalid datetime re-prompts
- [ ] Empty optional fields allowed (press Enter to skip)
- [ ] Task stored with correct auto-generated fields
- [ ] Success message shows assigned ID
- [ ] All functions have docstrings

**Validation Command** (manual interactive test):
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase1
python -c "
from storage import TaskStorage
from commands import handle_add

storage = TaskStorage()

# This requires manual input - run interactively
# handle_add(storage)

# Then verify
# print('Tasks:', len(storage.list_tasks()))
"
```

**Note**: This task requires manual interactive testing. Test by running `handle_add()` and entering valid/invalid inputs.

---

### Task 8: Implement Update Command

**Short Title**: Create update Command

**Files to Update**:
- `phase1/commands.py`

**Spec Reference**:
- Spec Section 3.2.5 (update command - lines 234-277)
- Plan Step 5 (lines 273-287)

**Implementation Requirements**:
- `prompt_for_update_data(current_task: dict) -> dict`
  - For each field (title, description, category, masjid_name, area_name, due_datetime):
    - Display current value
    - Prompt "New {field} (press Enter to keep current):"
    - If empty input, skip (don't include in updates dict)
    - If not empty, validate and add to updates dict
  - For category: show menu like in `prompt_category()`
  - For datetime: use `prompt_datetime()` logic
  - Return dict of only changed fields
- `handle_update(storage: TaskStorage, args: List[str]) -> None`
  - Check if `args` empty â†’ error: "Error: Command 'update' requires argument(s). Usage: update <id>"
  - Validate ID with `validators.validate_id(args[0])`
  - If invalid â†’ error: "Error: Invalid task ID. Please enter a number."
  - Fetch task with `storage.get_task(id)`
  - If not found â†’ error: "Error: Task with ID {id} not found."
  - Display: "Updating Task ID: {id}\n"
  - Call `prompt_for_update_data(task)`
  - Add `updated_at = datetime.now()` to updates
  - Call `storage.update_task(id, updates)`
  - Display: "Task updated successfully!"

**Success Criteria**:
- [ ] Shows current values for all fields
- [ ] Allows keeping current value (press Enter)
- [ ] Accepts new values and validates them
- [ ] Updates only changed fields
- [ ] Updates `updated_at` timestamp
- [ ] Handles missing ID argument
- [ ] Handles invalid ID format
- [ ] Handles non-existent task ID
- [ ] All functions have docstrings

**Validation Command** (manual):
```bash
# Interactive test required
# Add a task first, then update it and verify changes
```

---

### Task 9: Implement Delete and Complete Commands

**Short Title**: Create delete, complete, uncomplete Commands

**Files to Update**:
- `phase1/commands.py`

**Spec Reference**:
- Spec Section 3.2.6 (delete - lines 280-300)
- Spec Section 3.2.7 (complete - lines 303-318)
- Spec Section 3.2.8 (uncomplete - lines 321-336)
- Plan Step 5 (lines 289-308)

**Implementation Requirements**:
- `confirm_deletion(task: dict) -> bool`
  - Display: "Are you sure you want to delete this task?"
  - Display: "  ID: {id}"
  - Display: "  Title: {title}"
  - Prompt: "Confirm deletion? (y/n):"
  - Return `True` if input is 'y' or 'Y'
  - Return `False` otherwise
- `handle_delete(storage: TaskStorage, args: List[str]) -> None`
  - Check args, validate ID (same pattern as update)
  - Fetch task
  - Call `confirm_deletion(task)`
  - If confirmed: call `storage.delete_task(id)` and show "Task deleted successfully!"
  - Else: show "Deletion cancelled."
- `handle_complete(storage: TaskStorage, args: List[str]) -> None`
  - Check args, validate ID
  - Fetch task
  - If already completed: show "Task ID {id} is already completed."
  - Else: update with `completed=True, updated_at=datetime.now()` and show "Task ID {id} marked as completed!"
- `handle_uncomplete(storage: TaskStorage, args: List[str]) -> None`
  - Check args, validate ID
  - Fetch task
  - If already incomplete: show "Task ID {id} is already incomplete."
  - Else: update with `completed=False, updated_at=datetime.now()` and show "Task ID {id} marked as incomplete!"

**Success Criteria**:
- [ ] `delete` prompts for confirmation with task details
- [ ] Entering 'y' deletes task
- [ ] Entering 'n' cancels deletion
- [ ] `complete` marks task as completed
- [ ] `complete` on already completed shows message
- [ ] `uncomplete` marks task as incomplete
- [ ] `uncomplete` on already incomplete shows message
- [ ] All commands validate ID properly
- [ ] `updated_at` timestamp updated correctly
- [ ] All functions have docstrings

**Validation Command** (manual):
```bash
# Interactive test: add task, complete it, uncomplete it, delete it
```

---

### Task 10: Implement Main REPL Loop

**Short Title**: Create Main Application Entry Point

**Files to Update**:
- `phase1/main.py`

**Spec Reference**:
- Spec Section 4.2 (Command Loop - lines 368-376)
- Spec Section 4.3 (Error Handling - lines 378-382)
- Spec Section 3.2.9 (Exit message - lines 339-349)
- Plan Step 6 (lines 332-391)

**Implementation Requirements**:
- `parse_command(user_input: str) -> tuple[str, List[str]]`
  - Strip and split input on whitespace
  - First token is command (lowercase)
  - Remaining tokens are args
  - Handle empty input â†’ return `("", [])`
  - Return `(command, args)`
- `dispatch_command(cmd: str, args: List[str], storage: TaskStorage) -> bool`
  - Match `cmd` to handlers:
    - `"help"` â†’ `commands.handle_help(storage)`
    - `"add"` â†’ `commands.handle_add(storage)`
    - `"list"` â†’ `commands.handle_list(storage, args)`
    - `"view"` â†’ `commands.handle_view(storage, args)`
    - `"update"` â†’ `commands.handle_update(storage, args)`
    - `"delete"` â†’ `commands.handle_delete(storage, args)`
    - `"complete"` â†’ `commands.handle_complete(storage, args)`
    - `"uncomplete"` â†’ `commands.handle_uncomplete(storage, args)`
    - `"exit"` â†’ return `False`
    - unknown â†’ print "Error: Unknown command '{cmd}'. Type 'help' for available commands."
  - Return `True` to continue loop, `False` to exit
- `main() -> None`
  - Create `TaskStorage` instance
  - Call `display.show_welcome_banner()`
  - Call `display.show_help()`
  - Loop:
    - Print prompt: `"salaatflow> "` (with space, no newline)
    - Read user input
    - Call `parse_command(input)`
    - Call `dispatch_command(cmd, args, storage)`
    - If returns `False`, break loop
  - Print farewell: "JazakAllah Khair for using SalaatFlow! May your deeds be accepted."
- Add `if __name__ == "__main__": main()` at end

**Success Criteria**:
- [ ] Application starts with banner and help
- [ ] Prompt displays as "salaatflow> "
- [ ] All commands execute correctly
- [ ] Unknown command shows error
- [ ] `exit` displays farewell message and exits
- [ ] Application doesn't crash on any input
- [ ] Ctrl+C exits gracefully (optional: catch KeyboardInterrupt)
- [ ] Can be run with: `python main.py`

**Validation Command**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase1
python main.py
# Test: help, add, list, exit
```

---

### Task 11: Execute Test Session 1 - Basic CRUD

**Short Title**: Test Basic CRUD Operations

**Files to Create**:
- `phase1/TESTING.md` (create and document results)

**Spec Reference**:
- Spec Section 5.1 (Test Session 1 - lines 387-475)
- Plan Step 7 (lines 402-410)

**Test Procedure**:
1. Start application: `python main.py`
2. Add task 1: "Attend Fajr at Masjid Al-Huda" (category: Farz, masjid: Masjid Al-Huda, area: DHA Phase 5, due: 2025-12-28 05:30)
3. Add task 2: "Read Surah Yaseen after Fajr" (category: Sunnah, no masjid/area/due)
4. Add task 3: "Give charity today" (category: Deed, description: "Donate to local food bank")
5. Run `list` â†’ verify 3 tasks shown, all pending
6. Run `complete 1` â†’ verify success message
7. Run `list` â†’ verify task 1 shows [âœ“] status
8. Run `delete 2` â†’ confirm with 'y' â†’ verify success
9. Run `list` â†’ verify only tasks 1 and 3 remain

**Success Criteria**:
- [ ] All add operations succeed and show correct IDs
- [ ] List shows correct number of tasks
- [ ] Complete operation updates status correctly
- [ ] List reflects completion status change
- [ ] Delete prompts for confirmation
- [ ] Delete removes task from list
- [ ] Output matches spec examples exactly
- [ ] No crashes or unexpected errors

**Documentation Requirement**:
Create `phase1/TESTING.md` with:
```markdown
# Test Session 1: Basic CRUD Operations
Date: [today]
Tester: Claude Code

## Test Steps
[Document each step with actual output]

## Result
PASS / FAIL

## Notes
[Any deviations or issues]
```

---

### Task 12: Execute Test Session 2 - Filtering

**Short Title**: Test Task Filtering

**Files to Update**:
- `phase1/TESTING.md` (append results)

**Spec Reference**:
- Spec Section 5.2 (Test Session 2 - lines 479-507)
- Plan Step 7 (lines 412-420)

**Test Procedure** (continuing from Session 1 state):
1. Run `list pending` â†’ verify only task 3 shown (1 task, 0 completed, 1 pending)
2. Run `list completed` â†’ verify only task 1 shown (1 task, 1 completed, 0 pending)
3. Run `list all` â†’ verify both tasks shown (2 tasks, 1 completed, 1 pending)
4. Run `list invalid_filter` â†’ verify error message

**Success Criteria**:
- [ ] `list pending` shows only incomplete tasks
- [ ] `list completed` shows only completed tasks
- [ ] `list all` shows all tasks
- [ ] Summary counts are correct for each filter
- [ ] Invalid filter shows appropriate error
- [ ] Output matches spec format

**Documentation Requirement**:
Append to `TESTING.md`:
```markdown
# Test Session 2: Filtering Tasks
[Document steps and results]
Result: PASS / FAIL
```

---

### Task 13: Execute Test Session 3 - Update Task

**Short Title**: Test Task Update

**Files to Update**:
- `phase1/TESTING.md` (append results)

**Spec Reference**:
- Spec Section 5.3 (Test Session 3 - lines 511-570)
- Plan Step 7 (lines 422-430)

**Test Procedure** (continuing from Session 2 state):
1. Run `view 3` â†’ note created/updated timestamps
2. Run `update 3`:
   - Keep title (press Enter)
   - Change description to "Donate $50 to Masjid Al-Noor"
   - Keep category (press Enter)
   - Change masjid to "Masjid Al-Noor"
   - Change area to "Gulshan-e-Iqbal"
   - Change due to "2025-12-27 18:00"
3. Run `view 3` again â†’ verify changes and timestamps

**Success Criteria**:
- [ ] Update shows current values
- [ ] Pressing Enter keeps current values
- [ ] New values are accepted and validated
- [ ] All updated fields reflect changes
- [ ] `updated_at` timestamp changed
- [ ] `created_at` timestamp unchanged
- [ ] Output matches spec format

**Documentation Requirement**:
Append to `TESTING.md`:
```markdown
# Test Session 3: Update Task
[Document steps, before/after values, timestamps]
Result: PASS / FAIL
```

---

### Task 14: Execute Test Session 4 - Error Handling

**Short Title**: Test Error Cases

**Files to Update**:
- `phase1/TESTING.md` (append results)

**Spec Reference**:
- Spec Section 5.4 (Test Session 4 - lines 574-598)
- Plan Step 7 (lines 432-440)

**Test Procedure**:
1. Run `invalid_command` â†’ verify error message
2. Run `delete` (no ID) â†’ verify usage error
3. Run `delete 999` â†’ verify not found error
4. Run `complete abc` â†’ verify invalid ID error
5. Run `view 999` â†’ verify not found error
6. Run `list invalid_filter` â†’ verify invalid filter error

**Success Criteria**:
- [ ] Unknown command shows: "Error: Unknown command 'invalid_command'. Type 'help' for available commands."
- [ ] Missing argument shows: "Error: Command 'delete' requires argument(s). Usage: delete <id>"
- [ ] Non-existent ID shows: "Error: Task with ID 999 not found."
- [ ] Invalid ID format shows: "Error: Invalid task ID. Please enter a number."
- [ ] Invalid filter shows: "Error: Invalid filter. Use: all, pending, or completed"
- [ ] Application continues running after each error
- [ ] No crashes

**Documentation Requirement**:
Append to `TESTING.md`:
```markdown
# Test Session 4: Error Handling
[Document each error case and actual message]
Result: PASS / FAIL
```

---

### Task 15: Execute Test Session 5 - Complete Workflow

**Short Title**: Test Full Daily Workflow

**Files to Update**:
- `phase1/TESTING.md` (append results and final summary)

**Spec Reference**:
- Spec Section 5.5 (Test Session 5 - lines 602-666)
- Plan Step 7 (lines 442-450)

**Test Procedure** (start fresh or continue):
1. Add task 4: "Pray Dhuhr at office" (Farz, area: Clifton, due: 2025-12-27 13:30)
2. Add task 5: "Recite Ayat-ul-Kursi before sleep" (Sunnah, due: 2025-12-27 23:00)
3. Run `list pending` â†’ verify 3+ pending tasks
4. Run `complete 4` â†’ verify success
5. Run `uncomplete 1` â†’ verify success (toggles back to incomplete)
6. Run `list` â†’ verify task 4 is completed, task 1 is incomplete
7. Run `exit` â†’ verify farewell message

**Success Criteria**:
- [ ] All operations work seamlessly
- [ ] Task counts correct throughout
- [ ] Complete/uncomplete toggle status properly
- [ ] Exit displays: "JazakAllah Khair for using SalaatFlow! May your deeds be accepted."
- [ ] Workflow represents realistic daily usage
- [ ] No unexpected behavior

**Documentation Requirement**:
Append to `TESTING.md`:
```markdown
# Test Session 5: Complete Workflow
[Document full workflow]
Result: PASS / FAIL

---

# Overall Test Summary
- Session 1: PASS / FAIL
- Session 2: PASS / FAIL
- Session 3: PASS / FAIL
- Session 4: PASS / FAIL
- Session 5: PASS / FAIL

Phase I Acceptance Testing: PASS / FAIL

## Issues Found
[List any bugs or deviations]

## Resolution
[How issues were resolved - spec refinement and code regeneration]
```

---

### Task 16: Create Complete README Documentation

**Short Title**: Write User Documentation

**Files to Create/Update**:
- `phase1/README.md`

**Spec Reference**:
- Plan Step 8 (lines 474-482)
- Spec Section 6 (Technical Requirements)

**Content Requirements**:
1. **Project Description**:
   - What is SalaatFlow
   - Phase I scope (in-memory console app)
   - Islamic spiritual task management concept
2. **Installation**:
   - Python 3.11+ requirement
   - No external dependencies
   - How to run: `python main.py`
3. **Command Reference**:
   - Table of all 9 commands with descriptions
   - Usage examples for each
4. **Example Usage Session**:
   - Step-by-step walkthrough
   - Add task, list, complete, delete, exit
5. **Domain Explanation**:
   - What are spiritual tasks
   - Category meanings (Farz, Sunnah, Nafl, Deed)
   - Masjid and area fields
6. **Phase I Limitations**:
   - In-memory only (no persistence)
   - No masjid database
   - No recurring tasks
   - No reminders
7. **What's Next**:
   - Phase II preview (database, web UI)
   - Link to spec: `/specs/phase1-cli.md`

**Success Criteria**:
- [ ] README is comprehensive and clear
- [ ] Installation steps work on fresh environment
- [ ] Example session matches actual behavior
- [ ] All 9 commands documented
- [ ] Islamic terminology explained
- [ ] Scope and limitations clearly stated
- [ ] Professional formatting with proper markdown
- [ ] Links to specs/constitution included

**Validation Command**:
```bash
# Follow README installation steps on fresh terminal
# Verify they work
```

---

### Task 17: Code Quality Review and Final Polish

**Short Title**: Final Code Review & Cleanup

**Files to Review/Update**:
- All `phase1/*.py` files

**Spec Reference**:
- Spec Section 6.4 (Code Quality Standards - lines 696-701)
- Plan Step 8 (lines 484-493)

**Review Checklist**:
- [ ] All functions have type hints
- [ ] All public functions have docstrings (Google/NumPy style)
- [ ] No hardcoded values (use constants from models/validators)
- [ ] Consistent error message formatting
- [ ] No code duplication (DRY principle)
- [ ] Category values exactly: "Farz", "Sunnah", "Nafl", "Deed"
- [ ] Datetime format exactly: "YYYY-MM-DD HH:MM"
- [ ] Field length limits enforced (title â‰¤200, description â‰¤1000, etc.)
- [ ] No TODOs or placeholder comments
- [ ] Module docstrings present in all files
- [ ] Imports organized (stdlib, then local)
- [ ] No unused imports or variables

**Optional Quality Checks**:
```bash
# Type checking (if mypy installed)
mypy phase1/ --ignore-missing-imports

# Linting (if pylint installed)
pylint phase1/*.py

# Code formatting check (if black installed)
black --check phase1/
```

**Success Criteria**:
- [ ] All checklist items verified
- [ ] No linting errors (if linter available)
- [ ] Code is clean and professional
- [ ] Ready for demo and Phase II evolution

**Final Smoke Test**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase1
python main.py
# Quick test: add task, list, complete, exit
# Verify output looks professional
```

---

## Task Completion Summary

When ALL 17 tasks are complete and passing:

âœ… **Phase I is DONE** and ready for:
- Demo to stakeholders
- Handoff to Phase II development
- Evolution to web app with database

---

## Appendix: Quick Reference

### Task Dependencies

```
1 (Setup) â†’ 2 (Models) â†’ 3 (Validators) â†’ 4 (Storage) â†’ 5 (Display) â†’
6 (Read Commands) â†’ 7 (Add) â†’ 8 (Update) â†’ 9 (Delete/Complete) â†’
10 (Main REPL) â†’ 11-15 (Testing) â†’ 16 (Docs) â†’ 17 (Polish)
```

### Validation Commands Summary

| Task | Quick Validation |
|------|------------------|
| 1-4 | `python -c "from phase1.models import *; from phase1.validators import *; from phase1.storage import TaskStorage; print('âœ“')"` |
| 5 | `python -c "from phase1.display import *; show_welcome_banner()"` |
| 6 | `python -c "from phase1.commands import handle_help; from phase1.storage import TaskStorage; handle_help(TaskStorage())"` |
| 7-10 | `cd phase1 && python main.py` (interactive) |
| 11-15 | Follow test sessions, document in TESTING.md |
| 16 | Read README, follow steps manually |
| 17 | Run smoke test, verify checklist |

### Files Inventory (17 Tasks Complete)

```
phase1/
â”œâ”€â”€ main.py              âœ… Task 10
â”œâ”€â”€ models.py            âœ… Task 2
â”œâ”€â”€ storage.py           âœ… Task 4
â”œâ”€â”€ validators.py        âœ… Task 3
â”œâ”€â”€ display.py           âœ… Task 5
â”œâ”€â”€ commands.py          âœ… Tasks 6, 7, 8, 9
â”œâ”€â”€ README.md            âœ… Task 16
â””â”€â”€ TESTING.md           âœ… Tasks 11-15
```

---

**Task List Status**: âœ… Ready for Execution
**Next Command**: `/sp.implement` to begin code generation starting with Task 1
