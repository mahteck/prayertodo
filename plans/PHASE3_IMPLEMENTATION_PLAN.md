# Phase III Implementation Plan: AI-Powered Prayer & Masjid Chatbot

**Project**: SalaatFlow – Intelligent Prayer & Masjid Todo Assistant
**Phase**: III (AI-Powered Conversational Interface)
**Date**: 2025-12-29
**Generated By**: Claude Code (Spec-Driven Development)

---

## Executive Summary

This plan outlines the complete implementation of Phase III, which adds an AI-powered conversational interface to the existing Phase II system. The implementation will be **100% generated by Claude Code** based on the detailed specification, with no manual application code writing.

**Key Principle**: All changes are **incremental and additive**. Phase II backend and frontend will continue to work exactly as before. Phase III adds new capabilities without breaking existing functionality.

**Working Directory**: `/mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/`
(All Phase III code will be added here, not in a separate directory)

---

## Implementation Architecture Overview

```
phase2_new/
├── backend/                    # Existing Phase II FastAPI backend
│   ├── main.py                 # WILL BE MODIFIED: Add chatbot router
│   ├── models.py               # WILL BE MODIFIED: Add user_id, prayer-relative fields
│   ├── routers/
│   │   ├── tasks.py           # Existing
│   │   ├── masjids.py         # Existing
│   │   ├── hadith.py          # Existing
│   │   └── chatbot.py         # NEW: Chat endpoint
│   ├── chatbot/               # NEW: Chatbot service module
│   │   ├── __init__.py
│   │   ├── agent/
│   │   │   ├── __init__.py
│   │   │   ├── config.py      # Agent configuration
│   │   │   ├── agent.py       # OpenAI Agents SDK integration
│   │   │   └── prompts.py     # System prompts
│   │   ├── mcp_tools/
│   │   │   ├── __init__.py
│   │   │   ├── base.py        # Base MCP tool class
│   │   │   ├── spiritual_tasks.py
│   │   │   ├── masjids.py
│   │   │   └── hadith.py
│   │   ├── utils/
│   │   │   ├── __init__.py
│   │   │   ├── language.py    # Language detection
│   │   │   ├── datetime_parser.py
│   │   │   └── error_handler.py
│   │   └── config/
│   │       ├── __init__.py
│   │       ├── settings.py
│   │       └── error_messages.json
│   ├── requirements.txt        # WILL BE MODIFIED: Add openai, etc.
│   └── .env                    # WILL BE MODIFIED: Add OPENAI_API_KEY
│
└── frontend/                   # Existing Phase II Next.js frontend
    ├── app/
    │   ├── chat/              # NEW: Chat page
    │   │   └── page.tsx
    │   ├── tasks/             # Existing
    │   ├── masjids/           # Existing
    │   └── ...
    ├── components/
    │   ├── chat/              # NEW: Chat UI components
    │   │   ├── ChatInterface.tsx
    │   │   ├── MessageList.tsx
    │   │   ├── MessageInput.tsx
    │   │   └── TypingIndicator.tsx
    │   └── ...
    ├── lib/
    │   └── chatApi.ts         # NEW: Chat API client
    ├── package.json           # WILL BE MODIFIED: Add dependencies
    └── ...
```

---

## Milestone 1: Phase III Foundation & Configuration

**Goal**: Set up the Phase III directory structure, configuration files, and dependencies without breaking Phase II.

### 1.1 Directory Structure Setup

**Actions**:
1. Create `backend/chatbot/` directory with subdirectories:
   - `agent/`
   - `mcp_tools/`
   - `utils/`
   - `config/`
2. Create all `__init__.py` files to make Python modules
3. Verify Phase II backend still starts successfully

**Files Created**:
- `backend/chatbot/__init__.py`
- `backend/chatbot/agent/__init__.py`
- `backend/chatbot/mcp_tools/__init__.py`
- `backend/chatbot/utils/__init__.py`
- `backend/chatbot/config/__init__.py`

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "import chatbot; print('✅ Chatbot module structure OK')"
```

### 1.2 Backend Dependencies Installation

**Actions**:
1. Update `backend/requirements.txt` with Phase III dependencies
2. Install new dependencies
3. Verify Phase II backend still starts

**Dependencies to Add**:
```txt
# Phase III - AI Chatbot Dependencies
openai>=1.12.0           # OpenAI SDK (includes Agents SDK)
python-dateutil>=2.8.2   # Date/time parsing
langdetect>=1.0.9        # Language detection (optional, can use heuristics)
```

**Updated File**: `backend/requirements.txt`

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
pip install -r requirements.txt
python main.py  # Should start without errors
curl http://localhost:8000/health  # Should return healthy
```

### 1.3 Environment Configuration

**Actions**:
1. Update `backend/.env` with Phase III environment variables
2. Update `backend/.env.example` (for documentation)
3. Create `backend/chatbot/config/settings.py` to load these variables

**Environment Variables to Add** (in `backend/.env`):
```bash
# Phase III - Chatbot Configuration
OPENAI_API_KEY=sk-placeholder-will-be-set-by-user
CHATBOT_MODEL=gpt-4
CHATBOT_TEMPERATURE=0.7
CHATBOT_MAX_TOKENS=1000
CHATBOT_TIMEOUT=30
DEFAULT_AREA=North Nazimabad
DEFAULT_MASJID_ID=1
```

**Files Created/Modified**:
- `backend/.env` (MODIFIED - add Phase III vars)
- `backend/.env.example` (MODIFIED - add Phase III vars)
- `backend/chatbot/config/settings.py` (NEW)

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python -c "from chatbot.config.settings import OPENAI_API_KEY; print('✅ Settings loaded')"
```

### 1.4 Frontend Dependencies Installation

**Actions**:
1. Add chat UI dependencies to `frontend/package.json`
2. Install dependencies
3. Verify Phase II frontend still builds

**Dependencies to Add**:
```json
{
  "dependencies": {
    "react-markdown": "^9.0.1",
    "remark-gfm": "^4.0.0"
  }
}
```

**Note**: We will use plain React components instead of OpenAI ChatKit (which may have compatibility issues). We'll build a simple, custom chat interface.

**Updated File**: `frontend/package.json`

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
npm install
npm run build  # Should build successfully
```

### 1.5 Error Message Templates

**Actions**:
1. Create `backend/chatbot/config/error_messages.json` with all error templates from spec

**File Created**: `backend/chatbot/config/error_messages.json`

**Content** (excerpt):
```json
{
  "masjid_not_found": {
    "en": "I couldn't find a masjid named '{name}'. Could you check the spelling or try a different masjid?",
    "ur": "Mujhe '{name}' naam ki koi masjid nahi mili. Kya aap spelling check kar sakte hain ya doosri masjid try karein?"
  },
  "task_not_found": {
    "en": "I couldn't find that task. Would you like to see your current tasks?",
    "ur": "Mujhe woh task nahi mila. Kya aap apne current tasks dekhna chahenge?"
  }
}
```

**Validation**: File exists and is valid JSON

**Completion Criteria**:
- ✅ All directories created
- ✅ Dependencies installed (backend + frontend)
- ✅ Environment variables configured
- ✅ Error messages template created
- ✅ Phase II backend starts successfully
- ✅ Phase II frontend builds successfully
- ✅ No breaking changes to existing code

---

## Milestone 2: Backend Data Model Extensions

**Goal**: Extend Phase II models to support Phase III requirements (user_id, prayer-relative times, recurrence details) without breaking existing functionality.

**Dependencies**: Milestone 1 complete

### 2.1 Model Schema Updates

**Actions**:
1. Update `backend/models.py` to add Phase III fields to `SpiritualTask`:
   - `user_id: Optional[int]` (for multi-user support)
   - `minutes_before_prayer: Optional[int]`
   - `linked_prayer: Optional[str]` (enum: Fajr, Dhuhr, Asr, Maghrib, Isha, Jummah)
   - `recurrence_pattern: Optional[str]` (e.g., "every_day", "every_friday")

2. Update `Recurrence` enum to match spec:
   - Change from `NONE/DAILY/WEEKLY/MONTHLY` to lowercase: `None/daily/weekly/monthly`
   - Or add new field `recurrence_type` to distinguish from existing

**Strategy**: Add new optional fields without modifying existing fields. All new fields are `Optional` so existing records remain valid.

**Modified File**: `backend/models.py`

**Example Addition**:
```python
class LinkedPrayer(str, Enum):
    """Prayer names for linking tasks to prayer times"""
    FAJR = "Fajr"
    DHUHR = "Dhuhr"
    ASR = "Asr"
    MAGHRIB = "Maghrib"
    ISHA = "Isha"
    JUMMAH = "Jummah"

class SpiritualTask(SQLModel, table=True):
    # ... existing fields ...

    # Phase III additions for chatbot
    user_id: Optional[int] = Field(default=1, index=True)  # Default to user 1 for backward compat
    minutes_before_prayer: Optional[int] = Field(default=None)
    linked_prayer: Optional[LinkedPrayer] = Field(default=None)
    recurrence_pattern: Optional[str] = Field(default=None, max_length=50)
```

### 2.2 Database Migration

**Actions**:
1. Create Alembic migration for new fields
2. Run migration on development database
3. Verify existing tasks are not affected

**Commands**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
alembic revision --autogenerate -m "Add Phase III chatbot fields to SpiritualTask"
alembic upgrade head
```

**Validation**:
```bash
# Verify database schema updated
python -c "from database import engine; from sqlmodel import text;
with engine.connect() as conn:
    result = conn.execute(text('PRAGMA table_info(spiritual_tasks)'))
    print([row for row in result])"
```

### 2.3 API Route Updates (if needed)

**Actions**:
1. Review `routers/tasks.py` to ensure new fields are accepted in POST/PUT requests
2. Update if necessary (SQLModel should auto-handle new optional fields)
3. Add query filter for `user_id` in `list_tasks` endpoint

**Modified File**: `routers/tasks.py` (minor update to add user_id filter)

**Example**:
```python
@router.get("/", response_model=List[SpiritualTask])
async def list_tasks(
    session: Session = Depends(get_session),
    user_id: Optional[int] = Query(None, description="Filter by user ID"),  # NEW
    category: Optional[TaskCategory] = Query(None, description="Filter by category"),
    # ... rest of params
):
    query = select(SpiritualTask)

    if user_id:  # NEW
        query = query.where(SpiritualTask.user_id == user_id)

    # ... rest of query
```

**Validation**:
```bash
# Test that Phase II API still works
curl http://localhost:8000/api/v1/tasks
curl -X POST http://localhost:8000/api/v1/tasks \
  -H "Content-Type: application/json" \
  -d '{"title":"Test Task","category":"Farz","priority":"Medium","user_id":1}'
```

**Completion Criteria**:
- ✅ Models updated with Phase III fields
- ✅ Database migration created and applied
- ✅ Existing tasks remain intact
- ✅ API accepts new fields in requests
- ✅ API returns new fields in responses
- ✅ Phase II functionality unchanged

---

## Milestone 3: MCP Tools for Backend Integration

**Goal**: Implement MCP SDK tools that wrap Phase II backend APIs for use by the AI agent.

**Dependencies**: Milestone 1, 2 complete

### 3.1 Base MCP Tool Class

**Actions**:
1. Implement `backend/chatbot/mcp_tools/base.py`
2. Create `MCPTool` class with:
   - Tool metadata (name, description, input_schema)
   - Backend configuration (method, path)
   - `execute()` method to call backend API
   - `to_openai_tool_schema()` to convert to OpenAI function format
   - Error handling (map HTTP errors to error codes)

**File Created**: `backend/chatbot/mcp_tools/base.py`

**Key Features**:
- HTTP client using `requests` library
- Dynamic URL building with path parameters
- Query string and JSON body support
- Error mapping (404 → NOT_FOUND, 500 → BACKEND_ERROR)
- Logging of all tool calls

**Validation**:
```python
# Test base tool class
from chatbot.mcp_tools.base import MCPTool

test_tool = MCPTool(
    name="test_tool",
    description="Test tool",
    input_schema={"type": "object", "properties": {}},
    backend_config={"method": "GET", "path": "/api/v1/tasks"}
)
print(test_tool.to_openai_tool_schema())
```

### 3.2 Spiritual Task MCP Tools

**Actions**:
1. Implement `backend/chatbot/mcp_tools/spiritual_tasks.py`
2. Define tools:
   - `create_spiritual_task`
   - `list_spiritual_tasks`
   - `update_spiritual_task`
   - `complete_spiritual_task`
   - `uncomplete_spiritual_task`
   - `delete_spiritual_task`

**File Created**: `backend/chatbot/mcp_tools/spiritual_tasks.py`

**Example Tool Definition**:
```python
from chatbot.mcp_tools.base import MCPTool

create_task_tool = MCPTool(
    name="create_spiritual_task",
    description="Creates a new spiritual task (prayer, deed, etc.) for the user",
    input_schema={
        "type": "object",
        "properties": {
            "user_id": {"type": "integer"},
            "title": {"type": "string"},
            "category": {"type": "string", "enum": ["Farz", "Sunnah", "Nafl", "Deed", "Other"]},
            "priority": {"type": "string", "enum": ["High", "Medium", "Low"]},
            "masjid_id": {"type": "integer"},
            "due_datetime": {"type": "string", "format": "date-time"},
            "recurrence": {"type": "string"},
            "minutes_before_prayer": {"type": "integer"},
            "linked_prayer": {"type": "string"}
        },
        "required": ["user_id", "title", "category", "priority"]
    },
    backend_config={
        "method": "POST",
        "path": "/api/v1/tasks"
    }
)

TASK_TOOLS = [
    create_task_tool,
    # ... other tools
]

def get_task_tools():
    return [tool.to_openai_tool_schema() for tool in TASK_TOOLS]
```

**Validation**:
```python
from chatbot.mcp_tools.spiritual_tasks import get_task_tools
tools = get_task_tools()
print(f"✅ {len(tools)} task tools registered")
```

### 3.3 Masjid MCP Tools

**Actions**:
1. Implement `backend/chatbot/mcp_tools/masjids.py`
2. Define tools:
   - `list_masjids_by_area`
   - `search_masjid_by_name`
   - `get_masjid_details`
   - `get_prayer_time`

**File Created**: `backend/chatbot/mcp_tools/masjids.py`

**Validation**:
```python
from chatbot.mcp_tools.masjids import get_masjid_tools
tools = get_masjid_tools()
print(f"✅ {len(tools)} masjid tools registered")
```

### 3.4 Hadith MCP Tools

**Actions**:
1. Implement `backend/chatbot/mcp_tools/hadith.py`
2. Define tools:
   - `get_daily_hadith`

**File Created**: `backend/chatbot/mcp_tools/hadith.py`

**Validation**:
```python
from chatbot.mcp_tools.hadith import get_hadith_tools
tools = get_hadith_tools()
print(f"✅ {len(tools)} hadith tools registered")
```

### 3.5 Tool Registration System

**Actions**:
1. Implement `backend/chatbot/mcp_tools/__init__.py`
2. Create functions:
   - `get_all_tools()` - returns all tool schemas for agent
   - `execute_tool(tool_name, user_id, **kwargs)` - executes tool by name
3. Implement tool execution dispatcher

**File Created**: `backend/chatbot/mcp_tools/__init__.py`

**Example**:
```python
from chatbot.mcp_tools.spiritual_tasks import get_task_tools, TASK_TOOLS
from chatbot.mcp_tools.masjids import get_masjid_tools, MASJID_TOOLS
from chatbot.mcp_tools.hadith import get_hadith_tools, HADITH_TOOLS

def get_all_tools():
    """Returns all MCP tools in OpenAI function calling format"""
    tools = []
    tools.extend(get_task_tools())
    tools.extend(get_masjid_tools())
    tools.extend(get_hadith_tools())
    return tools

def execute_tool(tool_name: str, user_id: int, **kwargs):
    """Executes a tool by name"""
    tool_map = {
        **{tool.name: tool for tool in TASK_TOOLS},
        **{tool.name: tool for tool in MASJID_TOOLS},
        **{tool.name: tool for tool in HADITH_TOOLS},
    }

    if tool_name in tool_map:
        return tool_map[tool_name].execute(user_id, **kwargs)
    else:
        return {"error": "TOOL_NOT_FOUND"}
```

**Validation**:
```python
from chatbot.mcp_tools import get_all_tools, execute_tool

# Test tool registration
all_tools = get_all_tools()
print(f"✅ Total tools registered: {len(all_tools)}")

# Test tool execution (with backend running)
result = execute_tool("list_spiritual_tasks", user_id=1)
print(f"✅ Tool execution: {result}")
```

**Completion Criteria**:
- ✅ Base MCP tool class implemented
- ✅ All 6 spiritual task tools defined
- ✅ All 4 masjid tools defined
- ✅ Hadith tool defined
- ✅ Tool registration system working
- ✅ Tools can successfully call Phase II backend APIs
- ✅ Error handling properly maps backend errors

---

## Milestone 4: Utility Modules (Language, DateTime, Error Handling)

**Goal**: Implement utility modules for language detection, date/time parsing, and error handling.

**Dependencies**: Milestone 3 complete

### 4.1 Language Detection Utility

**Actions**:
1. Implement `backend/chatbot/utils/language.py`
2. Create `detect_language(text: str) -> str` function
3. Use heuristic-based detection (Urdu keyword matching)

**File Created**: `backend/chatbot/utils/language.py`

**Algorithm**:
```python
def detect_language(user_message: str) -> str:
    """
    Detects language (English or Urdu) from user message
    Returns: "en" or "ur"
    """
    urdu_keywords = [
        "aaj", "kal", "ka", "kya", "hai", "mujhe", "sunao",
        "do", "bana", "se", "pehle", "baad", "mein", "main",
        "namaz", "sadaqah", "karna", "chahiye"
    ]

    message_lower = user_message.lower()
    urdu_count = sum(1 for keyword in urdu_keywords if keyword in message_lower)

    return "ur" if urdu_count >= 2 else "en"
```

**Validation**:
```python
from chatbot.utils.language import detect_language

assert detect_language("Show me today's hadith") == "en"
assert detect_language("Aaj ka hadith sunao") == "ur"
assert detect_language("Fajr ka time kya hai?") == "ur"
print("✅ Language detection working")
```

### 4.2 Date/Time Parsing Utility

**Actions**:
1. Implement `backend/chatbot/utils/datetime_parser.py`
2. Create functions:
   - `parse_datetime_expression(text: str, masjid_prayer_times: dict) -> datetime`
   - `parse_relative_prayer_time(prayer: str, offset_minutes: int, masjid_times: dict) -> datetime`
3. Support patterns from spec (tomorrow, after Maghrib, etc.)

**File Created**: `backend/chatbot/utils/datetime_parser.py`

**Key Functions**:
```python
from datetime import datetime, timedelta
from dateutil import parser

def parse_datetime_expression(text: str, context: dict = None) -> datetime:
    """
    Parse natural language datetime expressions

    Supports:
    - "tomorrow at 5:30 AM"
    - "tomorrow Fajr"
    - "after Maghrib"
    - "in 2 hours"
    - "Jan 15"
    """
    # Implementation using dateutil.parser and custom patterns
    pass

def parse_relative_prayer_time(prayer: str, minutes_before: int, masjid_times: dict) -> datetime:
    """
    Calculate datetime relative to prayer time

    Example:
    prayer = "Fajr"
    minutes_before = 20
    masjid_times = {"fajr_time": "05:30"}

    Returns: today at 5:10 AM
    """
    pass
```

**Validation**:
```python
from chatbot.utils.datetime_parser import parse_datetime_expression, parse_relative_prayer_time
from datetime import datetime, timedelta

# Test relative dates
tomorrow = datetime.now() + timedelta(days=1)
result = parse_datetime_expression("tomorrow at 5:30 AM")
assert result.day == tomorrow.day
print("✅ DateTime parsing working")
```

### 4.3 Error Handler Utility

**Actions**:
1. Implement `backend/chatbot/utils/error_handler.py`
2. Create functions:
   - `format_error(error_code: str, language: str, **kwargs) -> str`
   - `load_error_messages() -> dict`
3. Load error templates from `config/error_messages.json`

**File Created**: `backend/chatbot/utils/error_handler.py`

**Example**:
```python
import json

def load_error_messages():
    with open("chatbot/config/error_messages.json", "r") as f:
        return json.load(f)

ERROR_MESSAGES = load_error_messages()

def format_error(error_code: str, language: str, **kwargs) -> str:
    """
    Format user-friendly error message

    Args:
        error_code: e.g., "masjid_not_found"
        language: "en" or "ur"
        **kwargs: Placeholder values like {name}, {area}

    Returns: Formatted error message
    """
    if error_code not in ERROR_MESSAGES:
        error_code = "backend_error"

    template = ERROR_MESSAGES[error_code].get(language, ERROR_MESSAGES[error_code]["en"])

    for key, value in kwargs.items():
        template = template.replace(f"{{{key}}}", str(value))

    return template
```

**Validation**:
```python
from chatbot.utils.error_handler import format_error

msg_en = format_error("masjid_not_found", "en", name="Test Masjid")
msg_ur = format_error("masjid_not_found", "ur", name="Test Masjid")

assert "Test Masjid" in msg_en
assert "Test Masjid" in msg_ur
print("✅ Error handler working")
```

**Completion Criteria**:
- ✅ Language detection utility implemented
- ✅ DateTime parsing utility implemented
- ✅ Error handler utility implemented
- ✅ All utilities have basic validation
- ✅ Error messages loaded from JSON

---

## Milestone 5: OpenAI Agents SDK Integration

**Goal**: Implement the AI agent using OpenAI Agents SDK with system prompts, tool registration, and conversation handling.

**Dependencies**: Milestones 3, 4 complete

### 5.1 Agent Configuration

**Actions**:
1. Implement `backend/chatbot/agent/config.py`
2. Define agent settings (model, temperature, max_tokens, etc.)

**File Created**: `backend/chatbot/agent/config.py`

**Content**:
```python
from chatbot.config.settings import CHATBOT_MODEL, CHATBOT_TEMPERATURE, CHATBOT_MAX_TOKENS, CHATBOT_TIMEOUT

AGENT_CONFIG = {
    "model": CHATBOT_MODEL,
    "temperature": CHATBOT_TEMPERATURE,
    "max_tokens": CHATBOT_MAX_TOKENS,
    "max_tool_calls": 10,
    "max_recursion_depth": 5,
    "timeout": CHATBOT_TIMEOUT,
}
```

### 5.2 System Prompt

**Actions**:
1. Implement `backend/chatbot/agent/prompts.py`
2. Write comprehensive system prompt from spec
3. Include:
   - SalaatFlow context
   - Capabilities
   - Tools available
   - Language handling rules
   - Safety/confirmation rules
   - Response formatting guidelines

**File Created**: `backend/chatbot/agent/prompts.py`

**Content** (from spec):
```python
SYSTEM_PROMPT = """
You are SalaatFlow Assistant, an AI-powered chatbot for managing spiritual tasks (prayers, deeds) and providing Islamic information.

Context:
- You help users manage their spiritual todo list (SpiritualTask) via natural language.
- You provide information about masjids and prayer times.
- You share daily hadith and spiritual reminders.
- Users can interact in English or Urdu/Roman Urdu.

Core Principles:
1. **Respect and Reverence**: Always use respectful Islamic terminology.
2. **User-Centric**: Respond in the user's language (English or Urdu).
3. **Accuracy**: Use tools to fetch accurate data from the backend.
4. **Safety**: Confirm before destructive operations (delete, bulk updates).
5. **Clarity**: If unclear, ask clarifying questions.

[... full prompt from spec ...]
"""
```

### 5.3 Agent Implementation

**Actions**:
1. Implement `backend/chatbot/agent/agent.py`
2. Create functions:
   - `initialize_agent()` - creates OpenAI Assistant
   - `run_agent(user_id, user_message, conversation_history)` - runs agent
   - `handle_tool_calls(tool_calls, user_id)` - executes tools via MCP
3. Integrate with OpenAI SDK

**File Created**: `backend/chatbot/agent/agent.py`

**Key Implementation**:
```python
from openai import OpenAI
from chatbot.agent.config import AGENT_CONFIG
from chatbot.agent.prompts import SYSTEM_PROMPT
from chatbot.mcp_tools import get_all_tools, execute_tool
from chatbot.config.settings import OPENAI_API_KEY
import time

client = OpenAI(api_key=OPENAI_API_KEY)

def initialize_agent():
    """Initialize OpenAI Assistant with tools"""
    tools = get_all_tools()

    assistant = client.beta.assistants.create(
        name="SalaatFlow Assistant",
        instructions=SYSTEM_PROMPT,
        tools=tools,
        model=AGENT_CONFIG["model"]
    )

    return assistant

def run_agent(agent, user_id: int, user_message: str, conversation_history: list):
    """
    Run the agent with a user message

    Returns: assistant's response message
    """
    # Create thread with conversation history
    thread = client.beta.threads.create(
        messages=conversation_history
    )

    # Add user message
    client.beta.threads.messages.create(
        thread_id=thread.id,
        role="user",
        content=user_message
    )

    # Run agent
    run = client.beta.threads.runs.create(
        thread_id=thread.id,
        assistant_id=agent.id
    )

    # Wait for completion and handle tool calls
    while run.status in ["queued", "in_progress", "requires_action"]:
        if run.status == "requires_action":
            tool_outputs = handle_tool_calls(
                run.required_action.submit_tool_outputs.tool_calls,
                user_id
            )
            run = client.beta.threads.runs.submit_tool_outputs(
                thread_id=thread.id,
                run_id=run.id,
                tool_outputs=tool_outputs
            )
        else:
            time.sleep(1)
            run = client.beta.threads.runs.retrieve(
                thread_id=thread.id,
                run_id=run.id
            )

    # Get final response
    messages = client.beta.threads.messages.list(thread_id=thread.id)
    assistant_message = messages.data[0].content[0].text.value

    return assistant_message

def handle_tool_calls(tool_calls, user_id):
    """Execute tool calls and return outputs"""
    tool_outputs = []

    for tool_call in tool_calls:
        tool_name = tool_call.function.name
        tool_args = json.loads(tool_call.function.arguments)

        # Execute tool via MCP
        result = execute_tool(tool_name, user_id, **tool_args)

        tool_outputs.append({
            "tool_call_id": tool_call.id,
            "output": json.dumps(result)
        })

    return tool_outputs
```

**Validation**:
```python
from chatbot.agent.agent import initialize_agent, run_agent

# Initialize agent
agent = initialize_agent()
print(f"✅ Agent initialized: {agent.id}")

# Test simple query
response = run_agent(
    agent,
    user_id=1,
    user_message="Hello",
    conversation_history=[]
)
print(f"✅ Agent response: {response}")
```

**Completion Criteria**:
- ✅ Agent configuration defined
- ✅ System prompt implemented
- ✅ Agent initialization working
- ✅ Agent can process messages
- ✅ Tool calling integrated
- ✅ Conversation history supported

---

## Milestone 6: Chatbot Backend API Endpoint

**Goal**: Create HTTP endpoint for chat that integrates with the agent and exposes it to the frontend.

**Dependencies**: Milestone 5 complete

### 6.1 Chat Router Implementation

**Actions**:
1. Implement `backend/routers/chatbot.py`
2. Create endpoints:
   - `POST /chat` - send message, get response
3. Integrate with agent from Milestone 5
4. Add logging for all chat requests

**File Created**: `backend/routers/chatbot.py`

**Implementation**:
```python
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List, Optional
import logging

from chatbot.agent.agent import initialize_agent, run_agent
from chatbot.utils.language import detect_language

router = APIRouter()
logger = logging.getLogger(__name__)

# Initialize agent once at startup
agent = None

@router.on_event("startup")
async def startup_event():
    global agent
    agent = initialize_agent()
    logger.info(f"✅ Chatbot agent initialized: {agent.id}")

class ChatMessage(BaseModel):
    role: str  # "user" or "assistant"
    content: str

class ChatRequest(BaseModel):
    user_id: int
    message: str
    conversation_history: Optional[List[ChatMessage]] = []

class ChatResponse(BaseModel):
    response: str
    status: str
    language: str

@router.post("/", response_model=ChatResponse)
async def chat(request: ChatRequest):
    """
    Chat endpoint - processes user message and returns agent response
    """
    try:
        # Detect language
        language = detect_language(request.message)

        # Convert conversation history to OpenAI format
        history = [
            {"role": msg.role, "content": msg.content}
            for msg in request.conversation_history
        ]

        # Run agent
        response = run_agent(
            agent,
            user_id=request.user_id,
            user_message=request.message,
            conversation_history=history
        )

        # Log interaction
        logger.info(f"User {request.user_id} ({language}): {request.message}")
        logger.info(f"Agent response: {response[:100]}...")

        return ChatResponse(
            response=response,
            status="success",
            language=language
        )

    except Exception as e:
        logger.error(f"Chat error: {str(e)}", exc_info=True)
        raise HTTPException(
            status_code=500,
            detail="I encountered an error while processing your request. Please try again."
        )
```

### 6.2 Register Chat Router in Main App

**Actions**:
1. Update `backend/main.py` to include chat router
2. Add router with prefix `/api/v1/chat`

**Modified File**: `backend/main.py`

**Addition**:
```python
# Add after existing router imports
from routers import tasks, masjids, hadith, chatbot

# Add after existing router registrations
app.include_router(
    chatbot.router,
    prefix=f"{settings.api_v1_prefix}/chat",
    tags=["Chatbot"],
)
```

### 6.3 Logging Configuration

**Actions**:
1. Configure Python logging for chatbot module
2. Log all:
   - Chat requests/responses
   - Tool calls
   - Errors

**Modified File**: `backend/main.py` (add logging config at startup)

**Example**:
```python
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('chatbot.log')
    ]
)
```

**Validation**:
```bash
# Start backend
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python main.py

# In another terminal, test chat endpoint
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "Hello",
    "conversation_history": []
  }'

# Expected response:
# {"response":"As-salamu alaykum! How can I assist you?","status":"success","language":"en"}
```

**Completion Criteria**:
- ✅ Chat router implemented
- ✅ POST /chat endpoint working
- ✅ Agent integration successful
- ✅ Language detection applied
- ✅ Logging configured
- ✅ Error handling in place
- ✅ Endpoint returns proper JSON response

---

## Milestone 7: Frontend Chat UI Implementation

**Goal**: Create chat page and UI components in Next.js frontend using custom React components.

**Dependencies**: Milestone 6 complete

### 7.1 Chat API Client

**Actions**:
1. Implement `frontend/lib/chatApi.ts`
2. Create API client functions:
   - `sendChatMessage(userId, message, history)`
3. Handle errors and timeouts

**File Created**: `frontend/lib/chatApi.ts`

**Implementation**:
```typescript
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

interface ChatMessage {
  role: 'user' | 'assistant';
  content: string;
}

interface ChatResponse {
  response: string;
  status: string;
  language: string;
}

export async function sendChatMessage(
  userId: number,
  message: string,
  conversationHistory: ChatMessage[]
): Promise<ChatResponse> {
  const response = await fetch(`${API_BASE_URL}/api/v1/chat`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      user_id: userId,
      message,
      conversation_history: conversationHistory,
    }),
  });

  if (!response.ok) {
    throw new Error('Failed to send message');
  }

  return response.json();
}
```

### 7.2 Chat UI Components

**Actions**:
1. Create `frontend/components/chat/` directory
2. Implement 4 components:
   - `ChatInterface.tsx` (main container)
   - `MessageList.tsx` (displays messages)
   - `MessageInput.tsx` (input box + send button)
   - `TypingIndicator.tsx` (loading indicator)

**Files Created**:

#### `frontend/components/chat/ChatInterface.tsx`
```typescript
'use client';

import { useState } from 'react';
import MessageList from './MessageList';
import MessageInput from './MessageInput';
import TypingIndicator from './TypingIndicator';
import { sendChatMessage } from '@/lib/chatApi';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export default function ChatInterface({ userId = 1 }: { userId?: number }) {
  const [messages, setMessages] = useState<Message[]>([
    {
      role: 'assistant',
      content: 'As-salamu alaykum! How can I assist you with your spiritual journey today?',
      timestamp: new Date(),
    },
  ]);
  const [isLoading, setIsLoading] = useState(false);

  const handleSendMessage = async (message: string) => {
    // Add user message
    const userMessage: Message = {
      role: 'user',
      content: message,
      timestamp: new Date(),
    };
    setMessages((prev) => [...prev, userMessage]);

    // Show typing indicator
    setIsLoading(true);

    try {
      // Send to API
      const response = await sendChatMessage(
        userId,
        message,
        messages.map(({ role, content }) => ({ role, content }))
      );

      // Add assistant response
      const assistantMessage: Message = {
        role: 'assistant',
        content: response.response,
        timestamp: new Date(),
      };
      setMessages((prev) => [...prev, assistantMessage]);
    } catch (error) {
      // Show error message
      const errorMessage: Message = {
        role: 'assistant',
        content: 'I encountered an error. Please try again.',
        timestamp: new Date(),
      };
      setMessages((prev) => [...prev, errorMessage]);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-[calc(100vh-200px)] max-w-4xl mx-auto">
      <MessageList messages={messages} />
      <TypingIndicator visible={isLoading} />
      <MessageInput onSend={handleSendMessage} disabled={isLoading} />
    </div>
  );
}
```

#### `frontend/components/chat/MessageList.tsx`
```typescript
'use client';

import { useEffect, useRef } from 'react';
import ReactMarkdown from 'react-markdown';

interface Message {
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
}

export default function MessageList({ messages }: { messages: Message[] }) {
  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  return (
    <div className="flex-1 overflow-y-auto p-4 space-y-4">
      {messages.map((msg, idx) => (
        <div
          key={idx}
          className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}
        >
          <div
            className={`max-w-[70%] p-3 rounded-lg ${
              msg.role === 'user'
                ? 'bg-orange-500 text-white'
                : 'bg-gray-800 text-gray-100'
            }`}
          >
            <ReactMarkdown className="prose prose-invert max-w-none">
              {msg.content}
            </ReactMarkdown>
            <div className="text-xs opacity-70 mt-2">
              {msg.timestamp.toLocaleTimeString()}
            </div>
          </div>
        </div>
      ))}
      <div ref={messagesEndRef} />
    </div>
  );
}
```

#### `frontend/components/chat/MessageInput.tsx`
```typescript
'use client';

import { useState } from 'react';

interface Props {
  onSend: (message: string) => void;
  disabled: boolean;
}

export default function MessageInput({ onSend, disabled }: Props) {
  const [input, setInput] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (input.trim() && !disabled) {
      onSend(input.trim());
      setInput('');
    }
  };

  return (
    <form onSubmit={handleSubmit} className="p-4 border-t border-gray-700">
      <div className="flex gap-2">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          disabled={disabled}
          placeholder="Type your message..."
          className="flex-1 px-4 py-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:outline-none focus:border-orange-500"
        />
        <button
          type="submit"
          disabled={disabled || !input.trim()}
          className="px-6 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Send
        </button>
      </div>
    </form>
  );
}
```

#### `frontend/components/chat/TypingIndicator.tsx`
```typescript
export default function TypingIndicator({ visible }: { visible: boolean }) {
  if (!visible) return null;

  return (
    <div className="px-4 py-2">
      <div className="flex items-center gap-2 text-gray-400">
        <div className="flex gap-1">
          <span className="w-2 h-2 bg-orange-500 rounded-full animate-bounce" style={{ animationDelay: '0ms' }} />
          <span className="w-2 h-2 bg-orange-500 rounded-full animate-bounce" style={{ animationDelay: '150ms' }} />
          <span className="w-2 h-2 bg-orange-500 rounded-full animate-bounce" style={{ animationDelay: '300ms' }} />
        </div>
        <span>SalaatFlow is typing...</span>
      </div>
    </div>
  );
}
```

### 7.3 Chat Page Route

**Actions**:
1. Create `frontend/app/chat/page.tsx`
2. Import and render `ChatInterface` component
3. Add page metadata and styling

**File Created**: `frontend/app/chat/page.tsx`

**Implementation**:
```typescript
import ChatInterface from '@/components/chat/ChatInterface';

export const metadata = {
  title: 'Chat - SalaatFlow',
  description: 'Chat with SalaatFlow AI Assistant',
};

export default function ChatPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-white mb-2">
          SalaatFlow Assistant
        </h1>
        <p className="text-gray-400">
          Ask me anything about your spiritual tasks, masjids, or daily hadith
        </p>
      </div>

      <ChatInterface userId={1} />
    </div>
  );
}
```

### 7.4 Navigation Link to Chat

**Actions**:
1. Find existing navigation component (likely in `components/` or `app/`)
2. Add link to `/chat` page

**Modified File**: (Navigation component - to be determined)

**Example Addition**:
```typescript
<Link href="/chat" className="nav-link">
  Chat Assistant
</Link>
```

**Validation**:
```bash
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/frontend
npm run dev

# Open browser: http://localhost:3000/chat
# Test:
# 1. Page loads successfully
# 2. Initial greeting message appears
# 3. Can type and send messages
# 4. Loading indicator shows while waiting
# 5. Receives responses from backend
```

**Completion Criteria**:
- ✅ Chat API client implemented
- ✅ All 4 chat components created
- ✅ Chat page route created
- ✅ Navigation link added
- ✅ UI matches Phase II theme (black/orange/white)
- ✅ Messages display correctly
- ✅ Markdown rendering works
- ✅ Loading states work
- ✅ Can send and receive messages

---

## Milestone 8: Enhanced Features (Recurrence, Prayer-Relative Times)

**Goal**: Implement advanced chatbot capabilities for handling recurring tasks and prayer-relative time parsing.

**Dependencies**: Milestones 1-7 complete

### 8.1 Enhanced DateTime Parser

**Actions**:
1. Extend `backend/chatbot/utils/datetime_parser.py`
2. Add advanced parsing for:
   - Prayer-relative times ("20 minutes before Fajr")
   - Recurrence patterns ("daily", "every Friday")
   - Complex expressions ("tomorrow Fajr", "after Maghrib")

**Modified File**: `backend/chatbot/utils/datetime_parser.py`

**Key Functions**:
```python
def parse_prayer_relative_time(
    prayer_name: str,
    offset_minutes: int,
    offset_direction: str,  # "before" or "after"
    masjid_prayer_times: dict,
    target_date: datetime = None
) -> datetime:
    """
    Calculate datetime relative to prayer time

    Example:
    parse_prayer_relative_time("Fajr", 20, "before", {"fajr_time": "05:30"})
    Returns: today at 5:10 AM
    """
    if target_date is None:
        target_date = datetime.now()

    # Get prayer time (HH:MM format)
    prayer_time_str = masjid_prayer_times.get(f"{prayer_name.lower()}_time")
    if not prayer_time_str:
        raise ValueError(f"Prayer time not found for {prayer_name}")

    # Parse time
    hour, minute = map(int, prayer_time_str.split(':'))
    prayer_datetime = target_date.replace(hour=hour, minute=minute, second=0, microsecond=0)

    # Apply offset
    if offset_direction == "before":
        result = prayer_datetime - timedelta(minutes=offset_minutes)
    else:  # after
        result = prayer_datetime + timedelta(minutes=offset_minutes)

    return result
```

### 8.2 Agent Prompt Enhancement for Recurrence

**Actions**:
1. Update `backend/chatbot/agent/prompts.py`
2. Add detailed instructions for handling:
   - Recurring task creation
   - Prayer-relative scheduling
   - Masjid context resolution

**Modified File**: `backend/chatbot/agent/prompts.py`

**Additional Prompt Content**:
```python
RECURRENCE_INSTRUCTIONS = """
## Recurring Tasks & Prayer-Relative Times

When user requests a recurring task:
1. Extract recurrence pattern:
   - "daily" or "every day" → recurrence: "Daily", recurrence_pattern: "every_day"
   - "every Friday" or "weekly" → recurrence: "Weekly", recurrence_pattern: "friday"
   - "monthly" → recurrence: "Monthly", recurrence_pattern: "1st" (or specify)

2. When user says "X minutes before [Prayer]":
   - First, resolve masjid (ask if not in context)
   - Use get_masjid_details tool to get prayer times
   - Calculate due_datetime using prayer time - X minutes
   - Store minutes_before_prayer: X and linked_prayer: "[Prayer]"

3. Example flow for "Daily Fajr reminder 20 minutes before":
   - Ask: "Which masjid's Fajr time should I use?"
   - User: "Masjid Al-Huda"
   - Call: search_masjid_by_name(name="Masjid Al-Huda")
   - Get masjid_id and fajr_time (e.g., "05:30")
   - Calculate: due_datetime = tomorrow 5:10 AM (5:30 - 20 min)
   - Call: create_spiritual_task(
       title="Fajr Reminder",
       category="Farz",
       recurrence="Daily",
       recurrence_pattern="every_day",
       minutes_before_prayer=20,
       linked_prayer="Fajr",
       masjid_id=masjid_id,
       due_datetime="2025-12-30T05:10:00"
     )
"""

# Append to main SYSTEM_PROMPT
SYSTEM_PROMPT = SYSTEM_PROMPT + "\n\n" + RECURRENCE_INSTRUCTIONS
```

### 8.3 Masjid Context Management

**Actions**:
1. Implement masjid resolution logic in agent
2. When masjid is mentioned:
   - Store in conversation context
   - Reuse for subsequent prayer time queries

**Note**: This is handled implicitly by the agent's conversation memory. Ensure the agent can reference previous messages to find masjid context.

**Validation**:
Test the complete flow:
```bash
# Start backend with chatbot
cd /mnt/d/Data/GIAIC/hackathon2_prayertodo/phase2_new/backend
source venv/bin/activate
python main.py

# Test via curl or frontend:
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "Kal se daily Fajr se 20 minutes pehle mujhe remind karna",
    "conversation_history": []
  }'

# Expected: Agent asks "Which masjid's Fajr time should I use?"

# Follow-up:
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "Masjid Al-Huda",
    "conversation_history": [
      {"role": "user", "content": "Kal se daily Fajr se 20 minutes pehle mujhe remind karna"},
      {"role": "assistant", "content": "Which masjid's Fajr time should I use?"}
    ]
  }'

# Expected: Task created with recurrence, minutes_before_prayer, linked_prayer
```

**Completion Criteria**:
- ✅ DateTime parser handles prayer-relative times
- ✅ Agent prompt includes recurrence instructions
- ✅ Agent can create recurring tasks
- ✅ Agent asks for masjid when needed
- ✅ Prayer times correctly calculated
- ✅ All fields (recurrence, minutes_before_prayer, linked_prayer) populated

---

## Milestone 9: Multi-Language Support Validation

**Goal**: Ensure the chatbot properly handles both English and Urdu/Roman Urdu conversations.

**Dependencies**: Milestones 1-8 complete

### 9.1 Language-Aware Response Formatting

**Actions**:
1. Update agent prompt to emphasize language mirroring
2. Ensure all MCP tool responses don't override language
3. Test with both languages

**Modified File**: `backend/chatbot/agent/prompts.py`

**Addition**:
```python
LANGUAGE_GUIDELINES = """
## Language Handling Rules

1. **Detect user language** from their message:
   - English: standard English words, no Urdu keywords
   - Urdu: contains keywords like "aaj", "kal", "kya", "hai", "mujhe", etc.

2. **Respond in user's language**:
   - If user writes in English → respond in English
   - If user writes in Urdu/Roman Urdu → respond in Urdu/Roman Urdu
   - Maintain language consistency throughout conversation

3. **Language switching**:
   - If user explicitly says "in English" or "English mein" → switch to English
   - If user says "Urdu mein" → switch to Urdu

4. **Hadith language**:
   - For English users: return hadith_text_en
   - For Urdu users: return hadith_text_ur
   - Always include source/reference

5. **Example responses**:

   English:
   - "I've added a Farz task 'Pray Fajr at Masjid Al-Huda' for tomorrow at 5:30 AM."
   - "You have 3 pending tasks for today."

   Urdu:
   - "Maine aapka Farz task 'Pray Fajr at Masjid Al-Huda' kal 5:30 AM ke liye add kar diya."
   - "Aaj ke liye aapke paas 3 pending tasks hain."
"""

SYSTEM_PROMPT = SYSTEM_PROMPT + "\n\n" + LANGUAGE_GUIDELINES
```

### 9.2 Hadith Language Selection

**Actions**:
1. Update `get_daily_hadith` MCP tool to return both en/ur fields
2. Let agent select appropriate language field based on conversation

**Modified File**: `backend/chatbot/mcp_tools/hadith.py`

**Update Tool**:
```python
# Tool returns both language versions
# Agent selects based on conversation language
get_hadith_tool = MCPTool(
    name="get_daily_hadith",
    description="Retrieves today's hadith in both English and Urdu. Agent should select appropriate language based on user's language.",
    input_schema={
        "type": "object",
        "properties": {},
        "required": []
    },
    backend_config={
        "method": "GET",
        "path": "/api/v1/hadith/today"
    }
)
```

### 9.3 Language Testing

**Actions**:
1. Test conversations in English
2. Test conversations in Urdu
3. Test language switching mid-conversation

**Test Scripts**:

**English Test**:
```bash
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "Show me today'\''s hadith in English",
    "conversation_history": []
  }'
# Expected: Hadith in English
```

**Urdu Test**:
```bash
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "Aaj ka hadith sunao",
    "conversation_history": []
  }'
# Expected: Hadith in Urdu
```

**Completion Criteria**:
- ✅ Language detection works for English/Urdu
- ✅ Agent responds in detected language
- ✅ Hadith returned in correct language
- ✅ Language switching works on explicit request
- ✅ All error messages respect language
- ✅ Task/masjid responses formatted in correct language

---

## Milestone 10: Safety & Confirmation Mechanisms

**Goal**: Implement confirmation prompts for destructive operations and proper error handling.

**Dependencies**: Milestones 1-9 complete

### 10.1 Confirmation Logic in Agent

**Actions**:
1. Update agent prompt to request confirmation before:
   - Deleting task(s)
   - Bulk operations (update/delete multiple)
2. Handle confirmation in multi-turn conversation

**Modified File**: `backend/chatbot/agent/prompts.py`

**Addition**:
```python
SAFETY_CONFIRMATION_RULES = """
## Safety & Confirmation Rules

**ALWAYS request confirmation before:**

1. **Deleting a single task**:
   - English: "Are you sure you want to delete the task '{task_title}'? (Yes/No)"
   - Urdu: "Kya aap '{task_title}' task delete karna chahte hain? (Haan/Nahi)"

2. **Deleting multiple tasks**:
   - English: "You want to delete {count} tasks. Are you sure? (Yes/No)"
   - Urdu: "{count} tasks delete hone wale hain. Kya aap sure hain? (Haan/Nahi)"

3. **Bulk updates**:
   - English: "This will reschedule {count} tasks to tomorrow. Confirm? (Yes/No)"
   - Urdu: "{count} tasks kal ke liye reschedule honge. Confirm karein? (Haan/Nahi)"

**Confirmation flow:**
1. Ask for confirmation
2. Wait for user response in next message
3. If user says "Yes"/"Haan"/affirmative → execute operation
4. If user says "No"/"Nahi"/negative → cancel, say "Operation cancelled"
5. If unclear → ask again: "Please reply with Yes or No"

**DO NOT request confirmation for:**
- Creating tasks
- Updating single task (non-destructive like reschedule)
- Marking task complete/incomplete
- Viewing/listing tasks
- Getting hadith or prayer times

**Important:**
- Before calling delete_spiritual_task tool, you MUST have received explicit confirmation
- Store confirmation state in conversation context
"""

SYSTEM_PROMPT = SYSTEM_PROMPT + "\n\n" + SAFETY_CONFIRMATION_RULES
```

### 10.2 Error Message Handling

**Actions**:
1. Ensure all MCP tools return structured errors
2. Agent formats errors using error_handler utility
3. Test all error scenarios from spec

**Error Scenarios to Test**:
- Masjid not found
- Task not found
- Invalid date/time
- Backend error

**Validation Script**:
```bash
# Test masjid not found
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "What time is Fajr at Masjid XYZ?",
    "conversation_history": []
  }'
# Expected: User-friendly error, not found message

# Test deletion confirmation
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "Delete my charity task for tomorrow",
    "conversation_history": []
  }'
# Expected: Confirmation request

# Follow-up with "Yes"
curl -X POST http://localhost:8000/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": 1,
    "message": "Yes",
    "conversation_history": [
      {"role": "user", "content": "Delete my charity task for tomorrow"},
      {"role": "assistant", "content": "Are you sure you want to delete...?"}
    ]
  }'
# Expected: Task deleted confirmation
```

**Completion Criteria**:
- ✅ Confirmation requested for delete operations
- ✅ Confirmation flow works correctly
- ✅ Bulk operation confirmations work
- ✅ All error scenarios handled gracefully
- ✅ Error messages user-friendly and in correct language
- ✅ No operations execute without confirmation

---

## Milestone 11: Acceptance Testing - 10 Conversation Scripts

**Goal**: Execute all 10 conversation scripts from the specification to validate complete Phase III functionality.

**Dependencies**: All previous milestones complete

### 11.1 Test Environment Setup

**Actions**:
1. Seed database with test data:
   - 3 masjids (Masjid Al-Huda, Masjid Usman, Masjid Al-Aqsa)
   - Today's hadith in both languages
   - Empty tasks for user_id=1
2. Start backend and frontend
3. Prepare test execution environment

**Seed Script** (`backend/seed_test_data.py`):
```python
from database import get_session
from models import Masjid, DailyHadith
from datetime import date

def seed_test_data():
    session = next(get_session())

    # Clear existing test data
    # (implementation)

    # Seed masjids
    masjids = [
        Masjid(
            id=1,
            name="Masjid Al-Huda",
            area_name="North Nazimabad",
            fajr_time="05:30",
            dhuhr_time="13:00",
            asr_time="16:30",
            maghrib_time="18:00",
            isha_time="19:30",
            jummah_time="13:30"
        ),
        # ... more masjids
    ]

    # Seed hadith
    hadith = DailyHadith(
        date=date.today(),
        hadith_text_en="The best of you are those who learn the Quran and teach it.",
        hadith_text_ur="تم میں سے بہترین وہ ہیں جو قرآن سیکھیں اور سکھائیں۔",
        source="Sahih Bukhari 5027"
    )

    # Add to database
    # (implementation)
```

### 11.2 Test Script Execution

For each of the 10 scripts from the specification (Section 6), create a test file that:
1. Sends the exact messages from the script
2. Verifies the agent's response matches expected content
3. Checks database state after operations

**Test Files to Create**:
- `backend/tests/test_script_01_create_task_english.py`
- `backend/tests/test_script_02_list_tasks_filters.py`
- `backend/tests/test_script_03_update_task_reschedule.py`
- `backend/tests/test_script_04_complete_delete_task.py`
- `backend/tests/test_script_05_masjid_search_urdu.py`
- `backend/tests/test_script_06_prayer_time_urdu.py`
- `backend/tests/test_script_07_masjid_not_found.py`
- `backend/tests/test_script_08_hadith_english.py`
- `backend/tests/test_script_09_hadith_urdu.py`
- `backend/tests/test_script_10_recurring_reminder.py`

**Example Test** (`test_script_01_create_task_english.py`):
```python
import requests
import json
from datetime import datetime

API_URL = "http://localhost:8000/api/v1/chat"

def test_script_01():
    """
    Script 1: Create Task (English)
    User: "Add a task to pray Fajr at Masjid Al-Huda tomorrow at 5:30 AM"
    Expected: Task created with correct fields
    """
    response = requests.post(API_URL, json={
        "user_id": 1,
        "message": "Add a task to pray Fajr at Masjid Al-Huda tomorrow at 5:30 AM",
        "conversation_history": []
    })

    data = response.json()

    # Assertions
    assert response.status_code == 200
    assert data["status"] == "success"
    assert "Farz task" in data["response"] or "added" in data["response"]

    # Verify task in database
    tasks_response = requests.get("http://localhost:8000/api/v1/tasks?user_id=1")
    tasks = tasks_response.json()

    assert len(tasks) == 1
    assert tasks[0]["title"] == "Pray Fajr at Masjid Al-Huda"
    assert tasks[0]["category"] == "Farz"
    assert tasks[0]["masjid_id"] == 1

    print("✅ Script 1 passed")

if __name__ == "__main__":
    test_script_01()
```

### 11.3 Manual Testing via Frontend

**Actions**:
1. Open frontend chat page
2. Execute each script manually through the UI
3. Verify:
   - Messages display correctly
   - Responses are accurate
   - Language handling works
   - Confirmations appear when needed
4. Document any issues found

**Manual Test Checklist**:
```markdown
## Manual Chat UI Tests

### Script 1: Create Task (English)
- [ ] User message sent successfully
- [ ] Agent response confirms task creation
- [ ] Task appears in tasks page
- [ ] All fields correct (category, priority, masjid, due_datetime)

### Script 2: List Tasks with Filters
- [ ] Agent lists correct filtered tasks
- [ ] Formatting is clear (numbered list)
- [ ] Task details accurate

### Script 3: Update Task (Reschedule)
- [ ] Agent identifies task correctly
- [ ] Reschedule calculation correct
- [ ] Confirmation message clear
- [ ] Database updated

### Script 4: Complete and Delete Task
- [ ] Mark complete works
- [ ] Confirmation requested for delete
- [ ] Delete executes after "Yes"
- [ ] Task removed from database

### Script 5: Masjid Search (Urdu)
- [ ] Language detected as Urdu
- [ ] Response in Urdu
- [ ] Masjids listed correctly
- [ ] Formatting appropriate

### Script 6: Prayer Time Query (Urdu)
- [ ] Language detected as Urdu
- [ ] Correct masjid + prayer time returned
- [ ] Response in Urdu

### Script 7: Masjid Not Found
- [ ] Error handled gracefully
- [ ] User-friendly message
- [ ] Suggestion to check spelling

### Script 8: Daily Hadith (English)
- [ ] Hadith text in English
- [ ] Source included
- [ ] Respectful formatting

### Script 9: Daily Hadith (Urdu)
- [ ] Language detected
- [ ] Hadith text in Urdu
- [ ] Source included

### Script 10: Recurring Reminder
- [ ] Agent asks for masjid clarification
- [ ] After clarification, task created
- [ ] All recurrence fields populated
- [ ] Prayer-relative time calculated correctly
```

### 11.4 Test Results Documentation

**Actions**:
1. Create `PHASE3_TEST_RESULTS.md` documenting:
   - Each script execution result
   - Pass/fail status
   - Any issues found
   - Screenshots of UI tests
2. Fix any failing tests
3. Re-run until all pass

**Completion Criteria**:
- ✅ All 10 conversation scripts pass (automated or manual)
- ✅ Database state verified for each script
- ✅ Frontend UI tested for all scripts
- ✅ No critical bugs found
- ✅ All Phase III acceptance criteria met

---

## Milestone 12: Documentation & Deployment Preparation

**Goal**: Create comprehensive documentation and prepare Phase III for deployment.

**Dependencies**: Milestone 11 complete

### 12.1 Phase III Documentation

**Actions**:
1. Create `PHASE3_README.md` with:
   - Overview of Phase III features
   - Architecture diagram
   - Setup instructions
   - API documentation
   - Troubleshooting guide

**File Created**: `PHASE3_README.md`

**Content Outline**:
```markdown
# Phase III: AI-Powered Prayer & Masjid Chatbot

## Overview
Phase III adds an AI-powered conversational interface...

## Features
- Natural language task management
- Multi-language support (English + Urdu)
- Masjid & prayer time queries
- Daily hadith retrieval
- Recurring prayer reminders

## Architecture
[Diagram of chatbot → agent → MCP tools → backend → database]

## Setup Instructions

### Prerequisites
- Phase II backend and frontend running
- OpenAI API key

### Installation
1. Backend setup:
   ```bash
   cd phase2_new/backend
   source venv/bin/activate
   pip install -r requirements.txt
   ```

2. Environment configuration:
   ```bash
   cp .env.example .env
   # Edit .env and add OPENAI_API_KEY
   ```

3. Run backend:
   ```bash
   python main.py
   ```

4. Frontend setup:
   ```bash
   cd phase2_new/frontend
   npm install
   npm run dev
   ```

5. Access chat:
   - Open http://localhost:3000/chat

## API Endpoints

### POST /api/v1/chat
Chat with the AI assistant

**Request:**
```json
{
  "user_id": 1,
  "message": "Add task to pray Fajr",
  "conversation_history": []
}
```

**Response:**
```json
{
  "response": "I've added a Farz task...",
  "status": "success",
  "language": "en"
}
```

## Troubleshooting

### Issue: Agent not responding
- Check OPENAI_API_KEY is set
- Check backend logs for errors
- Verify OpenAI API quota

### Issue: Tools not working
- Verify Phase II backend is running
- Check backend URL in settings
- Test MCP tools individually

## Testing

Run acceptance tests:
```bash
cd backend/tests
python test_script_01_create_task_english.py
# ... run all tests
```

## Deployment Considerations
- Set environment variables in production
- Configure CORS for production domain
- Monitor OpenAI API usage
- Set up logging aggregation
```

### 12.2 Environment Configuration Documentation

**Actions**:
1. Update `.env.example` with all Phase III variables
2. Document each variable's purpose
3. Provide example values

**File Modified**: `backend/.env.example`

**Content**:
```bash
# Phase II - Backend Configuration
DATABASE_URL=postgresql://user:password@localhost/salaatflow
API_V1_PREFIX=/api/v1
CORS_ORIGINS=http://localhost:3000,http://localhost:3001
HOST=0.0.0.0
PORT=8000
ENVIRONMENT=development

# Phase III - Chatbot Configuration
OPENAI_API_KEY=sk-your-openai-api-key-here
CHATBOT_MODEL=gpt-4  # or gpt-4-turbo, gpt-3.5-turbo
CHATBOT_TEMPERATURE=0.7
CHATBOT_MAX_TOKENS=1000
CHATBOT_TIMEOUT=30
DEFAULT_AREA=North Nazimabad
DEFAULT_MASJID_ID=1
```

### 12.3 Deployment Checklist

**Actions**:
1. Create `DEPLOYMENT_CHECKLIST.md`
2. List all steps for deploying Phase III

**File Created**: `DEPLOYMENT_CHECKLIST.md`

**Content**:
```markdown
# Phase III Deployment Checklist

## Pre-Deployment

- [ ] All 10 acceptance tests passing
- [ ] Manual UI testing complete
- [ ] No console errors in frontend
- [ ] No Python errors in backend logs
- [ ] Database migrations applied
- [ ] Environment variables documented

## Backend Deployment

- [ ] Install production dependencies
- [ ] Set production environment variables:
  - [ ] OPENAI_API_KEY
  - [ ] DATABASE_URL (production)
  - [ ] CORS_ORIGINS (production domain)
  - [ ] ENVIRONMENT=production
- [ ] Run database migrations
- [ ] Seed initial data (masjids, hadith)
- [ ] Configure logging (file + aggregation)
- [ ] Set up process manager (systemd/supervisor)
- [ ] Configure reverse proxy (nginx)
- [ ] Enable HTTPS
- [ ] Test health endpoint

## Frontend Deployment

- [ ] Update NEXT_PUBLIC_API_URL to production backend
- [ ] Run production build: `npm run build`
- [ ] Test build locally: `npm run start`
- [ ] Deploy to hosting (Vercel/Netlify/etc.)
- [ ] Verify all routes accessible
- [ ] Test chat functionality on production

## Post-Deployment Verification

- [ ] Backend health check: curl https://api.salaatflow.com/health
- [ ] Frontend loads: https://salaatflow.com
- [ ] Chat page accessible: https://salaatflow.com/chat
- [ ] Can send messages and receive responses
- [ ] Tasks created appear in tasks page
- [ ] All 10 conversation scripts work on production
- [ ] Error messages display properly
- [ ] Language switching works

## Monitoring Setup

- [ ] Configure OpenAI API usage monitoring
- [ ] Set up error tracking (Sentry/etc.)
- [ ] Enable server metrics (CPU, memory)
- [ ] Configure database monitoring
- [ ] Set up uptime monitoring

## Rollback Plan

If issues occur:
1. Switch frontend to Phase II only (remove chat link)
2. Disable chatbot router in backend
3. Investigate logs
4. Fix issues
5. Redeploy
```

### 12.4 Final Code Review

**Actions**:
1. Review all generated code for:
   - Security issues (API key exposure, SQL injection, etc.)
   - Performance bottlenecks
   - Code quality
   - Documentation completeness
2. Fix any issues found
3. Ensure `.gitignore` includes:
   - `.env`
   - `venv/`
   - `node_modules/`
   - `__pycache__/`
   - `*.log`

**File Modified**: `.gitignore`

**Additions**:
```
# Phase III additions
backend/chatbot.log
backend/.env
*.log
```

**Completion Criteria**:
- ✅ Complete documentation created
- ✅ Environment variables documented
- ✅ Deployment checklist created
- ✅ Code reviewed for security/quality
- ✅ .gitignore updated
- ✅ No sensitive data in repository
- ✅ README clear and comprehensive

---

## Implementation Execution Summary

### Phase III Components Created

**Backend (Python)**:
- `backend/chatbot/` module (full implementation)
  - `agent/` - OpenAI Agents SDK integration
  - `mcp_tools/` - MCP SDK tool wrappers
  - `utils/` - Language, datetime, error handling
  - `config/` - Settings and error messages
- `backend/routers/chatbot.py` - Chat API endpoint
- Updated `backend/models.py` - Extended SpiritualTask
- Updated `backend/requirements.txt` - Added dependencies

**Frontend (Next.js/React)**:
- `frontend/app/chat/page.tsx` - Chat page route
- `frontend/components/chat/` - Chat UI components
  - `ChatInterface.tsx`
  - `MessageList.tsx`
  - `MessageInput.tsx`
  - `TypingIndicator.tsx`
- `frontend/lib/chatApi.ts` - API client
- Updated `frontend/package.json` - Added dependencies

**Documentation**:
- `PHASE3_README.md` - Complete feature documentation
- `PHASE3_TEST_RESULTS.md` - Test execution results
- `DEPLOYMENT_CHECKLIST.md` - Deployment guide
- Updated `.env.example` - Phase III variables

**Tests**:
- 10 acceptance test scripts (one per conversation script)
- Manual test checklist

### Total Files Created: ~30
### Total Files Modified: ~8
### Total Lines of Code: ~3,000-4,000 (estimated)

---

## Success Metrics

Phase III is successful when:

1. ✅ All 10 conversation scripts from spec pass
2. ✅ No breaking changes to Phase II functionality
3. ✅ Multi-language support (EN/UR) works
4. ✅ All MCP tools call backend APIs successfully
5. ✅ Agent handles multi-step conversations
6. ✅ Confirmations requested for destructive ops
7. ✅ Error handling is user-friendly
8. ✅ Chat UI is responsive and matches Phase II theme
9. ✅ Logging captures all important events
10. ✅ No API keys or secrets committed to git
11. ✅ Documentation is complete and clear
12. ✅ 100% of code generated by Claude Code (no manual coding)

---

## Risk Mitigation

### Potential Risks & Mitigation Strategies

| Risk | Mitigation |
|------|------------|
| OpenAI API rate limits/costs | Set max_tokens, timeout; monitor usage |
| Agent infinite loops | Set max_tool_calls, max_recursion_depth |
| Backend API failures | Implement retries, error handling in MCP tools |
| Language detection inaccuracy | Use robust heuristics; allow explicit language override |
| Date/time parsing errors | Provide clear error messages; ask for clarification |
| Database migration issues | Test migrations on dev DB first; keep rollback script |
| Frontend build failures | Test builds incrementally after each component |
| Breaking Phase II | Test Phase II endpoints after each milestone |

---

## Next Steps (After This Plan)

1. **Run `/sp.tasks`** to break this plan into granular, actionable tasks
2. **Run `/sp.implement`** to have Claude Code generate all code according to this plan
3. **Execute Milestone by Milestone** in order (1 → 12)
4. **Validate at each milestone** before proceeding to next
5. **Test continuously** - run Phase II tests after each change
6. **Document issues** and iterate as needed
7. **Final validation** with all 10 conversation scripts

---

**End of Plan**

This plan is complete, detailed, and ready for execution via `/sp.tasks` and `/sp.implement`. All implementation will be done by Claude Code with zero manual application coding by humans.

**Assalamu Alaikum! Ready to build Phase III! 🚀**
